var documenterSearchIndex = {"docs":
[{"location":"alldocstrings/#All-Docstrings","page":"Reference","title":"All Docstrings","text":"","category":"section"},{"location":"alldocstrings/","page":"Reference","title":"Reference","text":"CurrentModule = LyoPronto","category":"page"},{"location":"alldocstrings/#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"alldocstrings/","page":"Reference","title":"Reference","text":"Modules = [LyoPronto]\nPages = [\"structs.jl\"]","category":"page"},{"location":"alldocstrings/#LyoPronto.PrimaryDryFit","page":"Reference","title":"LyoPronto.PrimaryDryFit","text":"PrimaryDryFit: a type for storing experimental data and indicating how it should be fit.\n\nProvided constructors:\n\nPrimaryDryFit(t_Tf, Tfs, Tf_iend, t_Tvw, Tvws, Tvw_iend, t_end)\nPrimaryDryFit(t_Tf, Tf::V) where V<:AbstractVector\nPrimaryDryFit(t_Tf, Tfs::T) where T<:Tuple\nPrimaryDryFit(t_Tf, Tfs, t_end::T) where T<:Unitful.Time\nPrimaryDryFit(t_Tf, Tfs, Tvw_end::T) where T<:Unitful.Temperature\nPrimaryDryFit(t_Tf, Tfs, Tvw_end::T1, t_end::T2) where {T1<:Unitful.Temperature, T2<:Unitful.Time}\nPrimaryDryFit(t_Tf, Tfs, t_Tvw, Tvws) \nPrimaryDryFit(t_Tf, Tfs, t_Tvw, Tvws, t_end)\n\nThe use of this struct is determined in large part by the implementation of  LyoPronto.obj_expT. If a given field is not available, set it to missing and things should basically work. At least t_Tf and Tfs are  expected to always be provided.\n\nWith the exception of the two-argument (t_Tf, Tf) constructor, Tfs and Tvws should always be tuples of vectors (one vector per time series).\n\nTf_iend and Tvw_iend default to [length(Tf) for Tf in Tfs] and [length(Tvw) for Tvw in Tvws],  respectively, with one value for each temperature series;  they are used to dictate if a given temperature series should be truncated sooner than the full length in the fitting procedure. This implies that all the Tf temperature series are valid initially at the same time points, then stop having measured values after a different number of measurements.\n\nt_end indicates an end of drying, particularly if taken from other measurements (e.g. from Pirani-CM convergence). If set to missing, it is ignored in the objective function.\n\nPrincipal Cases:\n\nConventional: provide only t_Tf, Tfs\nRF with measured vial wall: provide t_Tf, Tfs, t_Tvw, Tvws, \nRF, matching model Tvw to experimental Tf[end] without measured vial wall: provide t_Tf, Tfs, Tvws, set t_Tvw to missing\n\n\n\n\n\n","category":"type"},{"location":"alldocstrings/#LyoPronto.RampedVariable","page":"Reference","title":"LyoPronto.RampedVariable","text":"A convenience type for computing temperatures, pressures, etc. with multiple setpoints in sequence, and linear interpolation according to a fixed ramp rate between set points\n\nThree main constructors are available: For a non-varying value, call with one argument:\n\nRampedVariable(constant_setpt)\n\nFor one ramp from initial value to set point with indefinite hold, call with two arguments:\n\nRampedVariable(setpts, ramprate)\n\nAnd for multiple setpoints, call with three arguments:\n\nRampedVariable(setpts, ramprates, holds)\n\nWith three arguments, setpts, ramprates, and holds should all be vectors, with lengths N+1, N, N-1 respectively.\n\nThe resulting RampedVariable rv = RampedVariable(...) can be called as rv(x) at any (dimensionally consistent) value of x,  and will return the value at that time point along the ramp process.\n\nA plot recipe is also provided for this type, e.g. plot(rv; tmax=10u\"hr\") where tmax indicates where to stop drawing the last setpoint hold.\n\n\n\n\n\n","category":"type"},{"location":"alldocstrings/#LyoPronto.RpFormFit","page":"Reference","title":"LyoPronto.RpFormFit","text":"A convenience type for dealing with the common functional form given to Rp and Kv.\n\nAn object Rp = RpFormFit(A, B, C) can be called as Rp(x), which simply computes A + B*x/(1 + C*x). Likewise, Kv = RpFormFit(Kc, Kp, Kd) can be called as Kv(p) to get Kc + Kp*p/(1 + Kd*p).\n\nBe careful to pass dimensionally consistent values.\n\n\n\n\n\n","category":"type"},{"location":"alldocstrings/#Parameter-Fitting","page":"Reference","title":"Parameter Fitting","text":"","category":"section"},{"location":"alldocstrings/","page":"Reference","title":"Reference","text":"Modules = [LyoPronto]\nPages = [\"paramfits.jl\"]","category":"page"},{"location":"alldocstrings/#LyoPronto.gen_sol_conv_dim-NTuple{4, Any}","page":"Reference","title":"LyoPronto.gen_sol_conv_dim","text":"gen_sol_conv_dim(KRp_prm, otherparams, u0, tspan; kwargs...)\n\nSolve the Pikal model for primary drying with given Kv & Rp, returning the solution object and the set of parameters passed to solve.\n\notherparams contains: (hf0, c_solid, ρ_solution, Av, Ap, pch, Tsh)\nu0 is given as floats (not Unitful quantities), with dimensions [cm, K].\nKRp_prm has the form [Kv, R0, A1, A2]; this function assigns the units [W/m^2/K, cm^2*Torr*hr/g, cm*Torr*hr/g, 1/cm] to those numbers\nkwargs is passed directly (as is) to the ODE solve call.\n\nThis is used as a helper for obj_tT_conv to assemble a function which takes [Kv, R0, A1, A2] and returns sum squared error against experiment. To that end, use this to make an anonymous function of the form gen_sol = x->gen_sol_conv_dim(x, case_params, case_u0, case_tspan). That function is what you will pass to obj_tT_conv.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.gen_sol_rf_dim-NTuple{4, Any}","page":"Reference","title":"LyoPronto.gen_sol_rf_dim","text":"gen_sol_rf_dim(fitprm, params_bunch, u0, tspan; kwargs...)\n\nSolve the lumped-capacitance model for microwave-assisted primary drying with given fit parameters, returning the solution object and the set of parameters passed to solve.\n\nfitprm has the form [α, Kvwf, Bf, Bvw]; this function assigns the units [cm^1.5, cal/s/K/cm^2, Ω/m^2, Ω/m^2] to those numbers.\nparams_bunch contains a full listing of parameters used for the model, according to lumped_cap_rf, including dummy values for the fit parameters.\nu0 is given as floats (not Unitful quantities), with dimensions [g, K, K].\nkwargs is passed directly (as is) to the ODE solve call.\n\nThis is used as a helper for obj_tT_rf, obj_tTT_rf, obj_ttTT_rf to assemble a function which takes [α, Kvwf, Bf, Bvw] and returns sum squared error against experiment. To that end, use this to make an anonymous function of the form gen_sol = x->gen_sol_rf_dim(x, case_params, case_u0, case_tspan). That function is what you will pass to obj_tT_rf (or similar).\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.obj_expT-Tuple{Any, Any}","page":"Reference","title":"LyoPronto.obj_expT","text":"obj_expT(sol, pdfit; tweight=1, verbose=true, rf = true)\n\nExperimental (in the software engineering sense)! Evaluate an objective function which compares model solution computed by sol to experimental data in pdfit.\n\nsol is a solution to an appropriate model; see gen_sol_conv_dim and gen_sol_rf_dim for some helper functions for this.\npdfit is an instance of PrimaryDryFit, which contains some information about what to compare.\ntweight = 1 gives the weighting (in K^2/hr^2) of the total drying time in the objective, as compared to the temperature error.\n\nNote that if pdfit has vial wall temperatures (i.e. ismissing(pdfit.Tvws) == false), the third-index variable returned by gen_sol is assumed to be temperature, as is true for gen_sol_rf_dim.\n\nIf there are multiple series of Tf in pdfit, squared error is computed for each separately then summed; likewise for Tvw.\n\nI've considered writing several methods and dispatching on pdfit somehow, which would be cool and might individually be easier to read. But control flow might be harder to document and explain, and this should work just fine.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.obj_tTT_rf-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.obj_tTT_rf","text":"obj_tTT_rf(fitprm, gen_sol, tTTdat; t_end=0.0u\"hr\", tweight=1, verbose=true)\n\nEvaluate an objective function which compares model solution with fitprm to experimental data in tTTdat.\n\ngen_sol is a function taking [α, Kvwf, Bf, Bvw] and returning a solution to lumped-capacitance microwave-assisted model; see gen_sol_rf_dim.\ntTTdat is experimental temperature series, of the form (time, Tf, Tvw), so with frozen and vial wall temperatures taken at the same time points.    See also obj_tT_rf and obj_ttTT_rf.\ntweight gives the weighting (in K^2/hr^2) of the end of drying in the objective, as compared to the temperature error.\nt_end has a default value of 0.0u\"hr\", which (if left at default) is not included in the objective function.\nt_end defaults to missing, in which case it is excluded from the objective.   If another value is passed, then the model drying time is compared to that value and included in the objective.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.obj_tT_conv-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.obj_tT_conv","text":"obj_tT_conv(KRp_prm, gen_sol, tTdat; t_end=0.0u\"hr\", tweight=1, verbose = true)\n\nEvaluate an objective function which compares model solution with KRp_prm to experimental data in tTdat.\n\nArguments:\n\ngen_sol is a function taking [Kv, R0, A1, A2] and returning a solution to Pikal model; see gen_sol_conv_dim.\ntTdat is experimental temperature series, of the form (time, Tf).\ntweight gives the weighting (in K^2/hr^2) of the end of drying in the objective, as compared to the temperature error.\nt_end defaults to missing, in which case it is excluded from the objective.   If another value is passed, then the model drying time is compared to that value and included in the objective.\nverbose defaults to true, in which case each call to this function prints info on the passed parameters, etc.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.obj_tT_rf-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.obj_tT_rf","text":"obj_tT_rf(fitprm, gen_sol, tTdat; t_end=0.0u\"hr\", tweight=1, Tvw_end = 0.0u\"K\", verbose=true)\n\nEvaluate an objective function which compares model solution with fitprm to experimental data in tTdat.\n\ngen_sol is a function taking [α, Kvwf, Bf, Bvw] and returning a solution to lumped-capacitance microwave-assisted model; see gen_sol_rf_dim.\ntTTdat is experimental temperature series, of the form (time, Tf), so with frozen temperatures only.    See also obj_tTT_rf and obj_ttTT_rf.\nTvw_end defaults to missing, in which case vial wall temperatures are excluded from the objective.    If another value is passed, then the final model vial wall temperature is compared to that value and included in the objective.\ntweight gives the weighting (in K^2/hr^2) of the end of drying in the objective, as compared to the temperature error.\nt_end defaults to missing, in which case it is excluded from the objective.   If another value is passed, then the model drying time is compared to that value and included in the objective.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.obj_ttTT_rf-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.obj_ttTT_rf","text":"obj_ttTT_rf(fitprm, gen_sol, ttTTdat; t_end=missing, tweight=1, verbose=true)\n\nEvaluate an objective function which compares model solution with fitprm to experimental data in tTdat.\n\ngen_sol is a function taking [α, Kvwf, Bf, Bvw] and returning a solution to lumped-capacitance microwave-assisted model; see gen_sol_rf_dim.\nttTTdat is experimental temperature series, of the form (time_Tf, time_vw, Tf, Tvw), so with Tf and Tvw having separate time points.    This is useful if there is an early temperature rise in Tf, but Tvw continues to be reliable, so the model can fit to as much of Tvw as reasonable.   See also obj_tTT_rf and obj_tT_rf.\ntweight gives the weighting (in K^2/hr^2) of the end of drying in the objective, as compared to the temperature error.\nt_end defaults to missing, in which case it is excluded from the objective.   If another value is passed, then the model drying time is compared to that value and included in the objective.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#Plot-Recipes","page":"Reference","title":"Plot Recipes","text":"","category":"section"},{"location":"alldocstrings/","page":"Reference","title":"Reference","text":"Modules = [LyoPronto]\nPages = [\"recipes.jl\"]","category":"page"},{"location":"alldocstrings/#LyoPronto.exptfplot","page":"Reference","title":"LyoPronto.exptfplot","text":"exptfplot(time, T1, [T2, ...])\nexptfplot!(time, T1, [T2, ...])\n\nPlot recipe for one or more experimentally measured product temperatures, all at same times. This recipe adds one series for each passed temperature series, so pass labels as appropriate.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.exptfplot!","page":"Reference","title":"LyoPronto.exptfplot!","text":"exptfplot(time, T1, [T2, ...])\nexptfplot!(time, T1, [T2, ...])\n\nPlot recipe for one or more experimentally measured product temperatures, all at same times. This recipe adds one series for each passed temperature series, so pass labels as appropriate.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.exptvwplot","page":"Reference","title":"LyoPronto.exptvwplot","text":"exptvwplot(time, temperature; trim)\nexptvwplot!(time, temperature; trim)\n\nPlot recipe for a set of experimentally measured vial wall temperatures. This recipe adds only one series to the plot. trim is an integer, indicating how many points to skip at a time, so that  the dotted line looks dotted even with noisy data.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.exptvwplot!","page":"Reference","title":"LyoPronto.exptvwplot!","text":"exptvwplot(time, temperature; trim)\nexptvwplot!(time, temperature; trim)\n\nPlot recipe for a set of experimentally measured vial wall temperatures. This recipe adds only one series to the plot. trim is an integer, indicating how many points to skip at a time, so that  the dotted line looks dotted even with noisy data.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.modconvtplot","page":"Reference","title":"LyoPronto.modconvtplot","text":"modconvtplot(sols)\nmodconvtplot!(sols)\n\nPlot recipe for one or multiple solutions to the Pikal model, e.g. the output of gen_sol_conv_dim. This adds one series to the plot for each passed solution, so pass as many labels (e.g. [\"Tf1\" \"Tf2\"]) to this plot call as solutions to add labels to the legend.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.modconvtplot!","page":"Reference","title":"LyoPronto.modconvtplot!","text":"modconvtplot(sols)\nmodconvtplot!(sols)\n\nPlot recipe for one or multiple solutions to the Pikal model, e.g. the output of gen_sol_conv_dim. This adds one series to the plot for each passed solution, so pass as many labels (e.g. [\"Tf1\" \"Tf2\"]) to this plot call as solutions to add labels to the legend.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.modrftplot","page":"Reference","title":"LyoPronto.modrftplot","text":"modrftplot(sol)\nmodrftplot!(sol)\n\nPlot recipe for one solution to the lumped capacitance model, e.g. the output of gen_sol_rf_dim. This adds two series to the plot, so pass two labels (e.g. [\"Tf\" \"Tvw\"]) to this plot call to add labels to the legend.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.modrftplot!","page":"Reference","title":"LyoPronto.modrftplot!","text":"modrftplot(sol)\nmodrftplot!(sol)\n\nPlot recipe for one solution to the lumped capacitance model, e.g. the output of gen_sol_rf_dim. This adds two series to the plot, so pass two labels (e.g. [\"Tf\" \"Tvw\"]) to this plot call to add labels to the legend.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.qrf_integrate-Tuple{Any, Any}","page":"Reference","title":"LyoPronto.qrf_integrate","text":"qrf_integrate(sol, RF_params)\n\nCompute the integral over time of each heat transfer mode in the lumped capacitance model.\n\nReturns as a Dict{String, Quantity{...}}, with string keys Qsub, Qshf, Qvwf, QRFf, QRFvw.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.tendplot","page":"Reference","title":"LyoPronto.tendplot","text":"tendplot(t_end)\ntendplot!(t_end)\n\nPlot recipe that adds a labeled vertical line to the plot at time t_end.  A default label and styling are applied, but these can be modified by keyword arguments as usual\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.tendplot!","page":"Reference","title":"LyoPronto.tendplot!","text":"tendplot(t_end)\ntendplot!(t_end)\n\nPlot recipe that adds a labeled vertical line to the plot at time t_end.  A default label and styling are applied, but these can be modified by keyword arguments as usual\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#Vial-Dimensions","page":"Reference","title":"Vial Dimensions","text":"","category":"section"},{"location":"alldocstrings/","page":"Reference","title":"Reference","text":"Modules = [LyoPronto]\nPages = [\"get_vial_dims.jl\"]","category":"page"},{"location":"alldocstrings/#LyoPronto.get_vial_mass-Tuple{String}","page":"Reference","title":"LyoPronto.get_vial_mass","text":"get_vial_mass(vialsize::String)\n\nReturn vial mass for given ISO vial size.\n\nUses a table provided by Schott, stored internally in a CSV.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.get_vial_radii-Tuple{String}","page":"Reference","title":"LyoPronto.get_vial_radii","text":"get_vial_radii(vialsize::String)\n\nReturn inner and outer radius for passed ISO vial size.\n\nUses a table provided by Schott, stored internally in a CSV.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.get_vial_shape-Tuple{String}","page":"Reference","title":"LyoPronto.get_vial_shape","text":"get_vial_shape(vialsize::String)\n\nReturn a Dict{Symbol, Any} with a slew of vial dimensions, useful for drawing the shape of the vial with make_outlines.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.get_vial_thickness-Tuple{String}","page":"Reference","title":"LyoPronto.get_vial_thickness","text":"get_vial_thickness(vialsize::String)\n\nReturn vial wall thickness for given ISO vial size.\n\nUses a table provided by Schott, stored internally in a CSV.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.make_outlines-Tuple{Any, Any}","page":"Reference","title":"LyoPronto.make_outlines","text":"make_outlines(dims, Vfill)\n\nReturn a sequence of points (ready to be made into Plots.Shapes for the vial and fill volume, with Unitful dimensions, for given vial dimensions.\n\nThis is a convenience function for making figures illustrating fill depth.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#Model-Equations","page":"Reference","title":"Model Equations","text":"","category":"section"},{"location":"alldocstrings/","page":"Reference","title":"Reference","text":"Modules = [LyoPronto]\nPages = [\"model.jl\"]","category":"page"},{"location":"alldocstrings/#LyoPronto.end_drying_callback","page":"Reference","title":"LyoPronto.end_drying_callback","text":"A callback for use in simulating either the Pikal or RF model.\n\nTerminates the time integration when end_cond evaluates to true.\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.end_cond-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.end_cond","text":"end_cond(u, t, integ)\n\nCompute the end condition for primary drying (that mf or hf approaches zero).\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.lumped_cap_rf-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.lumped_cap_rf","text":"lumped_cap_rf(u, params, tn)\n\nCompute the right-hand-side function for the ODEs making up the lumped-capacitance microwave-assisted model.\n\nSpecifically, this is [dmf/dt, dTf/dt, dTvw/dt] given u = [mf, Tf, Tvw]. u is taken without units but assumed to have the units of [g, K, K] (which is internally added). tn is assumed to be in hours (internally added), so dudt is returned with assumed units [g/hr, K/hr, K/hr] to be consistent.\n\nThe full set of necessary parameters is given in the form of a tuple-of-tuples:\n\nparams = (   \n    (Rp, h_f0, cSolid, ρ_solution),\n    (K_shf_f, A_v, A_p),\n    (pch, Tsh, P_per_vial),\n    (m_f0, cp_f, m_v, cp_v, A_rad),\n    (f_RF, epp_f, epp_vw),\n    (K_vwf, B_f, B_vw, alpha),\n)\n\nThese should all be Unitful quantities with appropriate dimensions, with some exceptions which are callables returning quantities. See RpFormFit and RampedVariable for convenience types that can help with these cases.\n\nRp(x) with x a length returns mass transfer resistance (as a Unitful quantity)\nK_shf_f(p) with p a pressure returns heat transfer coefficient (as a Unitful quantity).\nTsh(t), pch(t), P_per_vial(t) return shelf temperature, chamber pressure, and microwave power respectively at time t.\nA_rad and alpha are used only in the LC2 and LC3 versions of the model, and can be left out.\n\nFor implementation details, see lumped_cap_rf_LC1.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.lumped_cap_rf_LC1-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.lumped_cap_rf_LC1","text":"lumped_cap_rf_LC1(u, params, tn)\n\nThis does the work for lumped_cap_rf, but returns dudt,  [Q_sub, Q_shf, Q_vwf, Q_RF_f, Q_RF_vw, Q_shw] with Q_... as Unitful quantities in watts.  The extra results are helpful in investigating the significance of the various heat transfer modes, but are not necessary in the ODE integration.\n\nLC1: Qshw evaluated with Kshf; shape factor included; α=0 My preferred version.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.lyo_1d_dae!-NTuple{4, Any}","page":"Reference","title":"LyoPronto.lyo_1d_dae!","text":"lyo_1d_dae!(du, u, params, t)\n\nInternal implementation of the Pikal model. See lyo_1d_dae_f for the wrapped version, which is more fully documented.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.lyo_1d_dae_f","page":"Reference","title":"LyoPronto.lyo_1d_dae_f","text":"lyo_1d_dae_f = ODEFunction(lyo_1d_dae!, mass_matrix=lyo_1d_mm)\n\nCompute the right hand side function for the Pikal model.\n\nThe DAE system which is the Pikal model (1 ODE, one nonlinear algebraic equation for pseudosteady conditions) is here treated as a constant-mass-matrix implicit ODE system. The implementation is in lyo_1d_dae!\n\nThe initial conditions u0 = [h_f, Tf] should be unitless, but are internally assigned to be in [cm, K]. The unitless time is taken to be in hours, so derivatives are given in unitless [cm/hr, K/hr].\n\nparams has the form:\n\nparams = (\n    (Rp, hf0, c_solid, ρ_solution),\n    (Kshf, Av, Ap),\n    (pch, Tsh) ,\n)\n\nwhere those listed following are callables returning Quantitys, and the rest are Quantitys. See RpFormFit and RampedVariable for convenience types that can help with the callables.\n\nRp(x) with x a length returns mass transfer resistance (as a Unitful quantity)\nKshf(p) with p a pressure returns heat transfer coefficient (as a Unitful quantity).\nTsh(t), pch(t) return shelf temperature and chamber pressure respectively at time t.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#Physical-Properties","page":"Reference","title":"Physical Properties","text":"","category":"section"},{"location":"alldocstrings/","page":"Reference","title":"Reference","text":"Modules = [LyoPronto, LyoPronto.Dielectric]\nPages = [\"physical_properties.jl\"]","category":"page"},{"location":"alldocstrings/#LyoPronto.calc_psub-Tuple{F} where F<:Number","page":"Reference","title":"LyoPronto.calc_psub","text":"calc_psub(T::F) where F<:Number\ncalc_psub(T::Q) where Q<:Quantity\n\nCompute pressure (in Pascals) of sublimation at temperature T in Kelvin.\n\nThis is essentially an Arrhenius fit, where we compute: psub = pref * exp(-ΔHsub*Mw/R/T)\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.Dielectric","page":"Reference","title":"LyoPronto.Dielectric","text":"Single-purpose module for computing the dielectric loss coefficient of ice, as a function of temperature and frequency. This module exports a function ϵpp_f(T, f) for doing so. (Set as a separate module just to keep namespaces clean.) This code is a nearly-direct implementation of the correlation, Eqs. 3-6 presented in: Takeshi Matsuoka, Shuji Fujita, Shinji Mae; Effect of temperature on dielectric properties of ice in the range 5–39 GHz. J. Appl. Phys. 15 November 1996; 80 (10): 5884–5890. https://doi.org/10.1063/1.363582\n\n\n\n\n\n","category":"module"},{"location":"example_conv/#Example:-Tuning-Mass-Transfer-Resistance","page":"Example, conventional lyo","title":"Example: Tuning Mass Transfer Resistance","text":"","category":"section"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"The source code for this example can be found in LyoPronto.jl/scripts/tuning_sucrose_Rp.jl. ","category":"page"},{"location":"example_conv/#Setup","page":"Example, conventional lyo","title":"Setup","text":"","category":"section"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"My current recommended approach for making use of this package is to have installed LyoPronto as a dependency of your project, according to the install instructions","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"For management of your project, DrWatson.jl is an effective tool which I like. I will demonstrate some usage of that tool here.","category":"page"},{"location":"example_conv/#Packages-Used","page":"Example, conventional lyo","title":"Packages Used","text":"","category":"section"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"First, we will load packages.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"using LyoPronto","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"LyoPronto reexports the following packages from OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve, DiffEqCallbacks, and Unitful, so those are available after using LyoPronto.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"The following packages are not exported by LyoPronto, so you will have to install them and import them as well to follow along here.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"using DrWatson\nusing CSV\nusing TypedTables\nusing LaTeXStrings\nusing SavitzkyGolay\nusing Optim\nusing Plots\nusing StatsPlots: @df\nusing Accessors","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"The following packages are used in this example:","category":"page"},{"location":"example_conv/#Loading-Experimental-Data","page":"Example, conventional lyo","title":"Loading Experimental Data","text":"","category":"section"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"First, load a .csv of experimental data with CSV and TypedTables. CSV.read method, and use DrWatson's datadir function to help keep directory structure clean.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"This file has 7 rows of metadata at the top, so the data headers are at row 8; it is located in the project directory under [project]/data/exp_raw/\"2024-06-21-16_MFD_AH.csv.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"data_raw = CSV.read(datadir(\"exp_raw\", \"2024-06-21-16_MFD_AH.csv\"), Table, header=8)","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"We can use the tools from TypedTables to make the native column names from the Millrock MicroFD lyophilizer a little more Julia-friendly, with a function like the following.  This function does the double duty of also attaching Unitful units to these columns. (This function can be put into your own package if you will use it often.)  ","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"function microfd_columnrename(row)\n    # nt = (tstamp = DateTime(row.Timestamp, dateformat\"mm/dd/yyyy H:M:S\"),\n    nt = (tstamp = row.CycleTime,\n          phase = row.Phase,\n          step = row.Step,\n          pch_sp = row.VacSetPT*u\"mTorr\",\n          pch_pir = row.VacPirani*u\"mTorr\",\n          pch_cm = row.VacCPM*u\"mTorr\",\n          Tsh_sp = row.ShelfSetPT*u\"°C\",\n          Tsh_i = row.ShelfInlet*u\"°C\",\n          T1 = row.TP1*u\"°C\",\n          T2 = row.TP2*u\"°C\",\n          T3 = row.TP4*u\"°C\", # Not a mistake: quirk of experimental apparatus that connection TP3 was more annoying than TP4\n          # if a column has names with whitespace \n          # or special characters in it, do this:\n          # mfr = row.var\"Mass Flow Rate\"\n    )\n    return nt\nend","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Apply this function as shown in the TypedTables tutorial, then we will add a column where time counts from 0 rather than being the time it was gathered. (We also need to account for how this cycle ran over several nights and so timesteps go to 0.)","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"procdata_pre = map(microfd_columnrename, data_raw)\nt = procdata_pre.tstamp .- procdata_pre.tstamp[1] .|> u\"hr\"\nfor _ in 1:7 # Check up to 7 days\n    # If the time isn't monotonically increasing... \n    all(t[2:end] .- t[1:end-1] .> 0u\"hr\") && break\n    # find the first place where it drops,\n    first_i = findfirst(t[2:end] .- t[1:end-1] .< 0u\"hr\") + 1\n    # and add 24 hours to the rest of the points\n    t[first_i:end] .+= 24u\"hr\"\nend\nprocdata = Table(procdata_pre; t=t)","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"To make sure you did this right, a good sanity check is to plot(t) and see that it is monotonically increasing.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"For the Millrock MicroFD lyophilizer that data was gathered on, the file has a column Phase indicating what step of the process is going on, so to select out the primary drying data out we can filter by rows where phase == 4:","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"pd_data = filter(x->x.phase == 4, procdata)\npd_data.t .-= pd_data.t[1]","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"To check that everything looks right, plot the temperatures, taking advantage of a recipe from this package, as well as the L\"[latex]\" macro from LaTeXStrings. We can also exploit the @df macro from StatsPlots to make this really smooth.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"@df pd_data exptfplot(:t, :T1, :T2, :T3, labels=[L\"T_{p1}\" L\"T_{p2}\" L\"T_{p3}\"])\n@df pd_data plot!(:t, :Tsh_sp, c=:black, label=L\"T_{sh}\")","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Look at the Pirani pressure and ascertain the end of drying by using a Savitzky-Golay filter to identify a maximum in the second derivative. Note that because SavitzkyGolay doesn't play nice with Unitful, we strip out units and add them back in. Another plot recipe plots the end of drying as a vertical line on that pressure graph.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"p_pir_sm = savitzky_golay(ustrip.(u\"mTorr\", pd_data.pch_pir), 91, 3, deriv=0).y *u\"mTorr\" # 91 a window width; 3 the polynomial order\np_pir_der2 = savitzky_golay(ustrip.(u\"mTorr\", pd_data.pch_pir), 91, 3, deriv=2).y\nt_end = pd_data.t[argmax(p_pir_der2[100:end])+99] # Skip past the beginning, where pressure might be weird\n@df pd_data plot(:t, :pch_pir, label=\"data\")\n@df pd_data plot!(:t, p_pir_sm, label=\"smoothed data\")\ntendplot!(t_end, label=L\"t_{end}\")","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Based on an examination of the temperature data, we want to go only up to the \"temperature rise\" commonly observed in lyophilization near (but not at) the end of drying. This happens at 7.5 hours for T1 and T3 and at about 12.5 hours for T2. To pass this information on to the least-squares fitting routine, one could manually trim down all the data to compare, which I have done many times. But since this is such a common operation, I made a tool which encodes this information:","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"fitdat_all = PrimaryDryFit(pd_data.t, \n                        (pd_data.T1[pd_data.t .< 7.5u\"hr\"],\n                        pd_data.T2[pd_data.t .< 12u\"hr\"],\n                        pd_data.T3[pd_data.t .< 7.5u\"hr\"]),\n                        t_end)","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Note that by passing all three temperature series to PrimaryDryFit, this will compare model output to all three temperature series. But in this case, T_1 might be an edge vial we want to fit separately, so let's actually use","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"fitdat_center = PrimaryDryFit(pd_data.t, \n                        (pd_data.T2[pd_data.t .< 12u\"hr\"],\n                        pd_data.T3[pd_data.t .< 7.5u\"hr\"]),\n                        t_end)\nfitdat_edge = PrimaryDryFit(pd_data.t, pd_data.T1[pd_data.t .< 7.5u\"hr\"])","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"There's also a plot recipe for this type–call plot(fitdat_center) and you can get an immediate feel if you got the right data or not.","category":"page"},{"location":"example_conv/#Set-up-model-parameters","page":"Example, conventional lyo","title":"Set up model parameters","text":"","category":"section"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Below, we make liberal use of Unitful units. Also note that RampedVariable and RpFormFit are used to simplify some common things we use.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"# Vial geometry\nvialsize = \"6R\"\nAp, Av = π.*get_vial_radii(vialsize).^2\n\n# Formulation parameters; Rp here is a placeholder guess\nc_solid = 0.05u\"g/mL\" # g solute / mL solution\nρ_solution = 1u\"g/mL\" # g/mL total solution density\nR0 = 0.8u\"cm^2*Torr*hr/g\"\nA1 = 14u\"cm*Torr*hr/g\"\nA2 = 1u\"1/cm\"\nRp = RpFormFit(R0, A1, A2)\n\n# Fill\nVfill = 3u\"mL\" # ml\nhf0 = Vfill / Ap\n\n# Cycle parameters\npch = RampedVariable(70u\"mTorr\") # constant pressure\nT_shelf_0 = -40.0u\"°C\" # initial shelf temperature\nT_shelf_final = -10.0u\"°C\"  # final shelf temperature\nramp_rate = 0.5 *u\"K/minute\" # ramp rate\n# Ramp for shelf temperature: convert to Kelvin because Celsius doesn't do math very well\nTsh = RampedVariable(uconvert.(u\"K\", [T_shelf_0, T_shelf_final]), ramp_rate)\n\n# Guess for heat transfer\nKC = 6.556e-5u\"cal/s/K/cm^2\"\nKP = 2.41e-3u\"cal/s/K/cm^2/Torr\"\nKD = 2.62u\"1/Torr\"\nKshf = RpFormFit(KC, KP, KD)\n# Alternative guess, without pressure dependence:\n# Kshf = p-> 5.0u\"W/m^2/K\"\n\nparams_bunch = [\n    (Rp, hf0, c_solid, ρ_solution),\n    (Kshf, Av, Ap),\n    (pch, Tsh)\n]\n\nparamobj = ParamObjPikal(params_bunch)\n","category":"page"},{"location":"example_conv/#Run-a-sanity-check-simulation","page":"Example, conventional lyo","title":"Run a sanity-check simulation","text":"","category":"section"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"# Time span: used to set initial time and to give an upper bound on time, in case parameters are bad\ntspan = (0.0, 100.0) # hours\n# Initial condition\nu0 = ustrip.([u\"cm\", u\"K\"], [hf0, Tsh(0u\"minute\")])\n\n# Set up as an ODE problem\nprob = ODEProblem(lyo_1d_dae_f, u0, tspan, paramobj)\n# Solve with the Rodas4P() algorithm, use a callback provided by LyoPronto to terminate at end of drying\nsol = solve(prob, Rodas4P(), callback=end_drying_callback)\n","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"And then plot these results with a recipe, to make sure that the chosen K_sh-f and R_p are physically reasonable guesses (though they will not be exact):","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"@df pd_data plot(:t, :Tsh_sp, c=:black, label=L\"T_{sh}\")\nplot!(fitdat_center)\ntendplot!(fitdat_center.t_end, label=L\"t_{end}\")\nmodconvtplot!(sol, label=L\"$T_p$, model\")","category":"page"},{"location":"example_conv/#Minimize-least-square-difference-to-compare-to-experimental-data","page":"Example, conventional lyo","title":"Minimize least square difference to compare to experimental data","text":"","category":"section"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"First, set up a function that takes K_sh-f and R_p and returns a solution object (see gen_sol_conv_dim ).","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"gen_sol_conv = KRp -> gen_sol_conv_dim(KRp, paramobj, u0, tspan)","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Next, set up an objective function we will minimize (see obj_expT for details), but basically: we use gen_sol_conv to generate a solution object, which is the first in a tuple of return values, and compare that solution to fitdat which are the fitting data selected above.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"obj_KRp = KRp ->  obj_expT(gen_sol_conv(KRp)[1], fitdat)","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"It's a good idea at this point to make sure that the objective function is working as expected:","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"KRp_guess = [12, 0.1, 5, 0.1]\nobj_KRp(KRp_guess)","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"should return a number.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Now, to actually carry out the fitting, we find a minimum for this objective function, using Optim with the NelderMead() algorithm:","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"opt_KRp = optimize(obj_KRp, KRp_guess, NelderMead())","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Get out the found values of our tuning parameters, and generate the corresponding solution profile:","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"KRp = Optim.minimizer(opt_KRp)\nprof, optparams = gen_sol_conv(KRp)","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Plot and compare experiment to model:","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"@df pd_data exptfplot(:t, :T1, :T2, :T3, labels=[L\"T_{p1}\" L\"T_{p2}\" L\"T_{p3}\"])\nplot!(Tsh, label=L\"T_{sh}\")\nmodconvtplot!(prof)\ntendplot!(t_end)\nplot!(xlim = (0, 20))","category":"page"},{"location":"example_conv/#Going-further","page":"Example, conventional lyo","title":"Going further","text":"","category":"section"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Suppose we want to fit a different K_v for the vial I said might be an edge vial, we can write another objective function for that, do new fitting, and add that to the plot.","category":"page"},{"location":"example_conv/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"# Write a general function that takes K, solves model\nfunction gen_sol_K_edge(K, po::ParamObjPikal, u0, timespan)\n    new_params = @set po.Kshf = x->(K*u\"W/m^2/K\")\n    prob = ODEProblem(lyo_1d_dae_f, u0, timespan, new_params)\n    sol = solve(prob, Rosenbrock23(autodiff=false), callback=end_drying_callback)\n    return sol, new_params\nend\n\n# Make a specific version for this experiment, with Rp tuned from above\ngen_sol_K = K->gen_sol_K_edge(K, optparams, u0, tspan)\n\nobj_K_edge = Kvec->obj_expT(gen_sol_K(Kvec[1])[1], fitdat_edge)\n\nopt_K_edge = optimize(obj_K_edge, [10.0], NelderMead())\n\nK_edge = Optim.minimizer(opt_K_edge)[1]\n\nprof_edge = gen_sol_K(K_edge)[1]\n\n@df pd_data exptfplot(:t, :T1, :T2, :T3, labels=[L\"T_{p1}\" L\"T_{p2}\" L\"T_{p3}\"])\nplot!(Tsh, label=L\"T_{sh}\", color=:black)\nmodconvtplot!(prof, prof_edge, labels=[L\"$T_{p}$, center\" L\"$T_{p}$, edge\"])\ntendplot!(t_end, label=L\"t_{end}\")\nplot!(xlim = (0, 20))","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#LyoPronto.jl","page":"Home","title":"LyoPronto.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package providing common computations for pharmaceutical lyophilization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This provides some of the functionality of LyoPRONTO, a Python package","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This relatively small package puts together some convenience functions useful for simulating primary drying in lyophilization.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a Julia package, this code can be easily installed with the Julia package manager. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"From the Julia REPL's Pkg mode (open a REPL and type ] so that the prompt turns blue), add this package as a Git repo:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/LyoHUB/LyoPronto.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"dev can be substituted for add if you want to make changes to this package yourself, as explained in the Julia Pkg manual.","category":"page"},{"location":"#Dependencies-and-Reexports","page":"Home","title":"Dependencies and Reexports","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package leverages the strengths of the DifferentialEquations.jl ecosystem to solve equations quickly and efficiently, although it only directly depends on OrdinaryDiffEqRosenbrock and DiffEqCallbacks, which are both reexported.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also provided are plot recipes for Plots.jl, although this package only depends on RecipesBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Heavy use is made of Unitful.jl, which is reexported.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Written by Isaac S. Wheeler, a PhD student at Purdue University. This work was supported in part by funding for NIIMBL project PC4.1-307 .","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"None yet. My intentions are to use the MIT license once this has been published in a scientific journal.","category":"page"}]
}
