var documenterSearchIndex = {"docs":
[{"location":"generated/fitting_mannitol/#Imports","page":"Example, conventional lyo","title":"Imports","text":"","category":"section"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"LyoPronto is this package. It reexports several other packages, so after using LyoPronto, you have effectively also done using Unitful and a few others.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"using LyoPronto","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"These are other packages that I use in the test suite, but you can use others in their place. TypedTables provides a lightweight table structure, not as broadly flexible as a DataFrame but great for our needs","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"using TypedTables, CSV","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"TransformVariables provides tools for mapping optimization parameters to sensible ranges.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"using TransformVariables","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Optimization provides a common interface to a variety of optimization packages, including Optim. We import it with OptimizationOptimJL to specify Optim as a backend. LineSearches gives a little more granular control over solver algorithms for Optim.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"using OptimizationOptimJL\nusing LineSearches","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Or, instead of using a scalar optimization package, we can use a least-squares solver.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"using NonlinearSolve","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Plots is a frontend for several plotting packages, and its companion package StatsPlots has a very nice macro I like.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"using Plots\nusing StatsPlots: @df\nusing LaTeXStrings","category":"page"},{"location":"generated/fitting_mannitol/#Read-in-process-data","page":"Example, conventional lyo","title":"Read in process data","text":"","category":"section"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"# Data start at 8th row of CSV file.\n# This needs to point to the right file, which for documentation is kinda wonky\nprocdata_raw = CSV.read(joinpath(@__DIR__, \"..\", \"..\", \"example\", \"2024-06-04-10_MFD_AH.csv\"), Table, header=8)\n# MicroFD, used for this experiment, has a column indicating primary drying\nt = uconvert.(u\"hr\", procdata_raw.CycleTime .- procdata_raw.CycleTime[1])\n# At midnight, timestamps revert to zero, so catch that case\nfor i in eachindex(t)[begin+1:end]\n    if t[i] < t[i-1]\n        t[i:end] .+= 24u\"hr\"\n    end\nend\n\n# Rename the columns we will use, and add units\nprocdata = map(procdata_raw) do row\n    # In the anonymous `do` function, `row` is a row of the table.\n    # Return a new row as a NamedTuple\n    (pirani = row.VacPirani * u\"mTorr\",\n     cm = row.VacCPM * u\"mTorr\",\n     T1 = row.TP1 * u\"°C\",\n     T2 = row.TP2 * u\"°C\",\n     T3 = row.TP4 * u\"°C\", # Quirk of this experimental run: TP3 slot was empty\n     Tsh = row.ShelfSetPT * u\"°C\",\n     phase = row.Phase\n    )\nend\nprocdata = Table(procdata, (;t)) # Append time to table\n\n# Count time from the beginning of experiment\npd_data = filter(row->row.phase == 4, procdata)\npd_data.t .-= pd_data.t[1]","category":"page"},{"location":"generated/fitting_mannitol/#Identify-one-definition-of-end-of-primary-drying-with-Savitzky-Golay-filter","page":"Example, conventional lyo","title":"Identify one definition of end of primary drying with Savitzky-Golay filter","text":"","category":"section"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"t_end = identify_pd_end(pd_data.t, pd_data.pirani, Val(:der2))","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Plots provides a very convenient macro @df which inserts table columns into a function call, which is very handy for plotting. Here this is combined with a recipe for plotting the pressure:","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"@df pd_data exppplot(:t, :pirani, :cm, (\"Pirani\", \"CM\"))\ntendplot!(t_end) # Use a custom recipe provided by LyoPronto for plotting t_end\nsavefig(\"pirani.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"(Image: )","category":"page"},{"location":"generated/fitting_mannitol/#Plot-the-temperature-data,-with-another-plot-recipe","page":"Example, conventional lyo","title":"Plot the temperature data, with another plot recipe","text":"","category":"section"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"To check that everything looks right, plot the temperatures, taking advantage of a recipe from this package, as well as the L\"[latex]\" macro from LaTeXStrings. We can also exploit the @df macro from StatsPlots to make this really smooth.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"@df pd_data exptfplot(:t, :T1, :T2, :T3, nmarks=40)\n@df pd_data plot!(:t, :Tsh, label=L\"T_{sh}\", c=:black)\nsavefig(\"exptemps.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"(Image: )","category":"page"},{"location":"generated/fitting_mannitol/#Plot-all-cycle-data-at-once-with-a-slick-recipe","page":"Example, conventional lyo","title":"Plot all cycle data at once with a slick recipe","text":"","category":"section"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"twinx(plot())\ncycledataplot!(procdata, (:T1, :T2, :T3), :Tsh, (:pirani, :cm), pcolor=:green, nmarks=40)\nsavefig(\"fullcycle.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"(Image: )","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Based on an examination of the temperature data, we want to go only up to the \"temperature rise\" commonly observed in lyophilization near (but not at) the end of drying. To pass this information on to the least-squares fitting routine, pass the temperatures up to the end of primary drying into a  PrimaryDryFit object. To be clear, no fitting happens yet: this object just wraps the data up for fitting.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"fitdat_all = @df pd_data PrimaryDryFit(:t, (:T1[:t .< 13u\"hr\"],\n                                    :T2[:t .< 13u\"hr\"],\n                                    :T3[:t .< 16u\"hr\"]);\n                                    t_end)\n# There is a plot recipe for this fit object\nplot(fitdat_all, nmarks=30)\nsavefig(\"pdfit.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"(Image: )","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"By passing all three temperature series to PrimaryDryFit, this will compare model output to all three temperature series at once.","category":"page"},{"location":"generated/fitting_mannitol/#Set-up-model","page":"Example, conventional lyo","title":"Set up model","text":"","category":"section"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"# Vial geometry\n# Ran with a 10mL vial, not strictly a 10R but with similar dimensions\nri, ro = get_vial_radii(\"10R\")\nAp = π*ri^2\nAv = π*ro^2\n\n# Formulation parameters\ncsolid = 0.05u\"g/mL\" # g solute / mL solution\nρsolution = 1u\"g/mL\" # g/mL total solution density\n# Provide some guess values for Rp, partly as a dummy for the model\nR0 = 0.8u\"cm^2*Torr*hr/g\"\nA1 = 14u\"cm*Torr*hr/g\"\nA2 = 1u\"1/cm\"\nRp = RpFormFit(R0, A1, A2)\n\n# Fill\nVfill = 3u\"mL\"\nhf0 = Vfill / Ap\n\n# Cycle parameters\npch = RampedVariable(100u\"mTorr\") # constant pressure\nT_shelf_0 = -40.0u\"°C\" # initial shelf temperature\nT_shelf_final = -10.0u\"°C\"  # final shelf temperature\nramp_rate = 0.5 *u\"K/minute\" # ramp rate\n# Ramp for shelf temperature: convert to Kelvin because Celsius doesn't do math very well\nTsh = RampedVariable(uconvert.(u\"K\", [T_shelf_0, T_shelf_final]), ramp_rate)\n\n# If we actually know the heat transfer as a function of pressure, we can use this form.\n# KC = 6.556e-5u\"cal/s/K/cm^2\"\n# KP = 2.41e-3u\"cal/s/K/cm^2/Torr\"\n# KD = 2.62u\"1/Torr\"\n# Kshf = RpFormFit(KC, KP, KD)\n# But for now, treat it as a constant guess\nKshf = ConstPhysProp(5.0u\"W/m^2/K\")\n\npo = ParamObjPikal([\n    (Rp, hf0, csolid, ρsolution),\n    (Kshf, Av, Ap),\n    (pch, Tsh)\n]);\nnothing #hide","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"As a sanity check, run the model to see that temperatures are in the right ballpark. Plot it with a recipe that attaches correct units.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"prob = ODEProblem(po)\nsol = solve(prob, Rodas3())\n@df pd_data exptfplot(:t, :T1, :T2, :T3, nmarks=20)\nmodconvtplot!(sol, label=L\"$T_p$, model\")\nsavefig(\"modelpre.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"(Image: )","category":"page"},{"location":"generated/fitting_mannitol/#Fit-model-parameters-to-match-data","page":"Example, conventional lyo","title":"Fit model parameters to match data","text":"","category":"section"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Optimization algorithms are happiest when they can run across all real numbers. So we use TransformVariables.jl to map all reals to positive values of our parameters, with sensible scales. The TVExp transform maps all real numbers to positive values, and the TVScale transform scales the value to a more reasonable range. The transform ConstWrapTV is defined in LyoPronto, and makes a constant callable function from a value.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"Kshf needs to be callable. Rp needs to be a callable, and the RpFormFit struct does that; by passing the new values with Rp as a NamedTuple, the constructor for ParamObjPikal will unpack it.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"trans_KRp = as((Kshf = ConstWrapTV() ∘ TVScale(Kshf(0)) ∘ TVExp(),\n                Rp=as((R0 = TVScale(R0) ∘ TVExp(),\n                A1 = TVScale(A1) ∘ TVExp(),\n                A2 = TVScale(A2) ∘ TVExp(),))))\n# Or, using a convenience function for the same,\ntrans_KRp = KRp_transform_basic(Kshf(0), R0, A1, A2)\ntrans_Rp = Rp_transform_basic(R0, A1, A2)","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"With this transform, we can set up the optimization problem. A good first step is to make sure the guess value is reasonable. In this case, I think that we should get good results with a zero guess","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"pg = fill(0.1, 4) # 4 parameters to optimize\npg = [1.0, 0.1, 0.1, 0.1] # 4 parameters to optimize\n# Not plotted since will produce the same as above, but this computes a solution\n@time LyoPronto.gen_sol_pd(pg, trans_KRp, po)\n\n# The optimization problem needs to know the transform, other parameters, and what data to fit\npass = (trans_KRp, po, fitdat_all)\n# The objective function will be obj_pd, which is compatible with automatic differentiation\nobj = OptimizationFunction(obj_pd, AutoForwardDiff())\n# Solve the optimization problem\noptalg = LBFGS(linesearch=LineSearches.BackTracking())\n@time opt = solve(OptimizationProblem(obj, pg, pass), optalg)","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"This works, but by using a scalar objective function, we throw away part of the problem structure–we have a least-squares problem, so the first derivative of the objective is essentially used to reconstruct the residuals that we could just be passing directly. To reformulate this, we can use a NonlinearLeastSquaresProblem.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"To avoid allocating a residual vector every time, we use an inplace function that needs to know how many residuals there are. The num_errs function looks at a PrimaryDryFit and counts the number of data points that can be used by obj_pd or nls_pd!.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"nls_eqs = NonlinearFunction{true}(nls_pd!, resid_prototype=zeros(num_errs(fitdat_all)))\n# After that, problem setup looks similar to the optimization approach\nnlsprob = NonlinearLeastSquaresProblem(nls_eqs, pg, pass)\n@time nls = solve(nlsprob, LevenbergMarquardt())","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"We should graph the results to see that they make sense.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"sol_opt = gen_sol_pd(opt.u, pass...)\nsol_nls = gen_sol_pd(nls.u, pass...)\n# Plot recipe for several temperature series:\n@df pd_data exptfplot(:t, :T1, :T2, :T3, nmarks=30, ylabel=\"Temperature\", xlabel=\"Time\")\n# And compare to the model output:\nmodconvtplot!(sol_opt, labsuffix=\", optimizer\")\nmodconvtplot!(sol_nls, labsuffix=\", least-squares\", c=:purple)\nsavefig(\"modelopt.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"(Image: )","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"And to get out our fit values, we can apply the transform to the values our optimizer found. Note that the direct least squares approach solves the same problem, but may not reach an identical local minimum because the algorithms take different paths.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"po_opt = transform(trans_KRp, opt.u)\npo_nls = transform(trans_KRp, nls.u)","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"To check goodness of fit, we can look at the objective being used for optimization. This objective is a normalized sum of squared error, so smaller is better.","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"[obj_expT(sol, fitdat_all) for sol in (sol_opt, sol_nls)]","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"","category":"page"},{"location":"generated/fitting_mannitol/","page":"Example, conventional lyo","title":"Example, conventional lyo","text":"This page was generated using Literate.jl.","category":"page"},{"location":"alldocstrings/#All-Docstrings","page":"Reference","title":"All Docstrings","text":"","category":"section"},{"location":"alldocstrings/#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"alldocstrings/#LyoPronto.PrimaryDryFit","page":"Reference","title":"LyoPronto.PrimaryDryFit","text":"PrimaryDryFit: a type for indicating how experimental data should be fit.\n\nProvided constructors:\n\nPrimaryDryFit(t, Tfs, Tvws, t_end)\nPrimaryDryFit(t, Tfs; Tvws=missing, t_end=missing) = PrimaryDryFit(t, Tfs, Tvws, t_end)\n\nNote that Tvws and t_end in the second constructors are keyword arguments, so either or both can be left out.\n\nThe use of this struct is determined in large part by the implementation of  LyoPronto.obj_expT and LyoPronto.err_expT!. If a given field is not  available, it will be set to missing and things should basically work. At least t and  Tfs are expected to always be provided.\n\nIn the end, Tfs and Tvws are each stored as a tuple of vectors, but the constructors try to  be flexible about allowing a single vector to be passed in place of a tuple of vectors.\n\nThe fields Tf_iend and Tvw_iend default to [length(Tf) for Tf in Tfs] and [length(Tvw) for Tvw in Tvws],  respectively, with one value for each temperature series;  they are used to dictate if a given temperature series should be truncated sooner than the full length in the fitting procedure. This implies that all the temperature series correspond to the same time points, then stop having measured values after a different number of measurements. If a single value is given for Tvws, then it is taken to be an endpoint, and Tvw_iend will be missing.\n\nt_end indicates an end of drying, particularly if taken from other measurements (e.g. from Pirani-CM convergence). If set to missing, it is ignored in the objective function. If set to a tuple of two times, then in the objective function any time  in that window is not penalized; outside that window, squared error takes over, as for the  single time case.\n\nPrincipal Cases:\n\nConventional: provide only t, Tfs\nConventional with Pirani ending: provide t, Tfs; t_end=...\nRF with measured vial wall: provide t, Tfs; Tvws=..., \nRF, matching model Tvw to experimental Tf[end] without measured vial wall: provide t, Tfs, Tvws=...\n\n\n\n\n\n","category":"type"},{"location":"alldocstrings/#LyoPronto.RampedVariable","page":"Reference","title":"LyoPronto.RampedVariable","text":"A convenience type for computing temperatures, pressures, etc. with multiple setpoints in sequence, and linear interpolation according to a fixed ramp rate between set points\n\nThree main constructors are available: For a non-varying value, call with one argument:\n\nRampedVariable(constant_setpt)\n\nFor one ramp from initial value to set point with indefinite hold, call with two arguments:\n\nRampedVariable(setpts, ramprate)\n\nAnd for multiple setpoints, call with three arguments:\n\nRampedVariable(setpts, ramprates, holds)\n\nWith three arguments, setpts, ramprates, and holds should all be vectors, with lengths N+1, N, N-1 respectively.\n\nThe resulting RampedVariable rv = RampedVariable(...) can be called as rv(x) at any (dimensionally consistent) value of x,  and will return the value at that time point along the ramp process.\n\nA plot recipe is also provided for this type, e.g. plot(rv; tmax=10u\"hr\") where tmax indicates where to stop drawing the last setpoint hold.\n\n\n\n\n\n","category":"type"},{"location":"alldocstrings/#LyoPronto.RpFormFit","page":"Reference","title":"LyoPronto.RpFormFit","text":"A convenience type for dealing with the common functional form given to Rp and Kv.\n\nAn object Rp = RpFormFit(A, B, C) can be called as Rp(x), which simply computes A + B*x/(1 + C*x). Likewise, Kv = RpFormFit(Kc, Kp, Kd) can be called as Kv(p) to get Kc + Kp*p/(1 + Kd*p).\n\nBe careful to pass dimensionally consistent values.\n\n\n\n\n\n","category":"type"},{"location":"alldocstrings/#Parameter-Fitting","page":"Reference","title":"Parameter Fitting","text":"","category":"section"},{"location":"alldocstrings/#LyoPronto.KBB_transform_basic-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.KBB_transform_basic","text":"KBB_transform_basic(Kvwfg, Bfg, Bvwg)\n\n\nConstruct a typical transform for fitting Kvwf, Bf, and Bvw (as for a microwave cycle).\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.KBB_transform_bounded-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.KBB_transform_bounded","text":"KBB_transform_bounded(\n    Kvwfg,\n    Bfg,\n    Bvwg;\n    Kvwf_scalefac,\n    Bf_scalefac,\n    Bvw_scalefac\n)\n\n\nConstruct a bounded transform for fitting Kvwf, Bf, and Bvw (as for a microwave cycle).\n\nKvwf_scalefac, Bf_scalefac, and Bvw_scalefac are used to provide upper and lower  bounds on the fitted parameter, as (Kvwfg/Kvwf_scalefac, Kvwfg*Kvwf_scalefac), etc. This is enforced with a logistic transform scaled and shifted appropriately.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.KRp_transform_basic-NTuple{4, Any}","page":"Reference","title":"LyoPronto.KRp_transform_basic","text":"KRp_transform_basic(Kshfg, R0g, A1g, A2g)\n\n\nConstruct a typical transform for fitting both Kshf and Rp.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.K_transform_basic-Tuple{Any}","page":"Reference","title":"LyoPronto.K_transform_basic","text":"K_transform_basic(Kshfg)\n\n\nConstruct a typical transform for fitting Kshf (a.k.a. Kv).\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.Rp_transform_basic-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.Rp_transform_basic","text":"Rp_transform_basic(R0g, A1g, A2g)\n\n\nConstruct a typical transform for fitting Rp.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.err_expT!-Tuple{Any, ODESolution, Any}","page":"Reference","title":"LyoPronto.err_expT!","text":"err_expT!(errs, sol, pdfit; tweight, verbose)\n\n\nEvaluate the error between model solution sol and experimental data in pdfit.\n\nThe in-place version err_expT! fills the errs vector with the errors, while the non-in-place version err_expT returns a new vector of errors. In-place err_expT! thus doesn't allocate, but requires errs to have length num_errs(pdfit).\n\nIn contrast to obj_expT(), which sums all the squared residuals, this function fills the passed array errs with each separate residual, which is suited for least squares algorithms.\n\nerrs is a vector of length num_errs(pdfit), which this function fills with the errors.\n\n-sol is a solution to an appropriate model; see gen_sol_pd for a helper function.\n\npdfit is an instance of PrimaryDryFit, which contains some information about what to compare.\ntweight = 1 gives the weighting (in K^2/hr^2) of the total drying time in the objective, as compared to the temperature error.\n\nEach time series, plus the end time, is given equal weight by dividing by its length; error is given in K (but ustripped).\n\nNote that if pdfit has vial wall temperatures (i.e. ismissing(pdfit.Tvws) == false), the third-index variable in sol is assumed to be temperature, as is true for solutions with ParamObjRF.\n\nIf there are multiple series of Tf in pdfit, error is computed for each separately; likewise for Tvw.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.err_expT-Tuple{Any, Any}","page":"Reference","title":"LyoPronto.err_expT","text":"err_expT(sol, pdfit; tweight, verbose)\n\n\nEvaluate the error between model solution sol and experimental data in pdfit.\n\nThe in-place version err_expT! fills the errs vector with the errors, while the non-in-place version err_expT returns a new vector of errors. In-place err_expT! thus doesn't allocate, but requires errs to have length num_errs(pdfit).\n\nIn contrast to obj_expT(), which sums all the squared residuals, this function fills the passed array errs with each separate residual, which is suited for least squares algorithms.\n\nerrs is a vector of length num_errs(pdfit), which this function fills with the errors.\n\n-sol is a solution to an appropriate model; see gen_sol_pd for a helper function.\n\npdfit is an instance of PrimaryDryFit, which contains some information about what to compare.\ntweight = 1 gives the weighting (in K^2/hr^2) of the total drying time in the objective, as compared to the temperature error.\n\nEach time series, plus the end time, is given equal weight by dividing by its length; error is given in K (but ustripped).\n\nNote that if pdfit has vial wall temperatures (i.e. ismissing(pdfit.Tvws) == false), the third-index variable in sol is assumed to be temperature, as is true for solutions with ParamObjRF.\n\nIf there are multiple series of Tf in pdfit, error is computed for each separately; likewise for Tvw.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.gen_nsol_pd-NTuple{4, Any}","page":"Reference","title":"LyoPronto.gen_nsol_pd","text":"gen_nsol_pd(fitlog, tr, pos, fitdats; badprms, kwargs...)\n\n\nGenerate multiple solutions at once.\n\nIf the transformation tr makes something (e.g. NamedTuple) with properties separate and  shared, then one each of separate is combined with shared, then they are matched up with each element of pos and fitdats. If pos is a single object, it is repeated. Further, if tr also has a field sep_inds, then those indices are used to map separate  to the sets of pos and fitdats. This is useful for when e.g. 2 sets of separate parameters  are to be applied across 5 different experiments.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.gen_sol_pd-NTuple{4, Any}","page":"Reference","title":"LyoPronto.gen_sol_pd","text":"gen_sol_pd(fitlog, tr, po, fitdat; badprms, kwargs...)\n\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.gen_sol_pd-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.gen_sol_pd","text":"gen_sol_pd(fitlog, tr, po; saveat, badprms, kwargs...)\n\n\nSimulate primary drying, given a vector of parameter guesses, a mapping tr from fitlog to named coefficients, and other parameters in po.\n\nThe equations used are determined by the type of po, which (with the magic of dispatch) is used to set up an ODE system.\n\ntr should be a TransformTuple object, from TransformVariables, which maps e.g. a vector of 3 real numbers to a NamedTuple with R0, A1, A2 as keys and appropriate Unitful dimensions on the values. This small function runs \n\nfitprm = transform(tr, fitlog)\nnew_params = setproperties(po, fitprm)\nprob = ODEProblem(new_params; tspan=(0.0, 1000.0))\nsol = solve(prob, Rodas4(autodiff=AutoForwardDiff(chunksize=2)); saveat, kwargs...)\n\nwhich is wrapped to avoid code duplication.\n\nSo, to choose which parameters to fitting, all that is necessary is to provide an appropriate transform tr and add a method of setproperties for the desired parameters. Therefore this function can be used for both K-Rp fitting, or just Rp, or just a subset of the 3 Rp coefficients.\n\nIf given, fitdat is used to set saveat for the ODE solution.\n\nOther kwargs are passed directly (as is) to the ODE solve call.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.nls_pd!-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.nls_pd!","text":"nls_pd!(errs, fitlog, tpf; tweight, verbose)\n\n\nCalculate the errors for fitting parameters to primary drying data. This directly calls gen_sol_pd, then err_expT!, so see those docstrings.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.nls_pd-Tuple{Any, Any}","page":"Reference","title":"LyoPronto.nls_pd","text":"nls_pd(fitlog, tpf; tweight, verbose)\n\n\nCalculate the errors for fitting parameters to primary drying data. This directly calls gen_sol_pd, then err_expT, so see those docstrings.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.num_errs-Tuple{Any}","page":"Reference","title":"LyoPronto.num_errs","text":"num_errs(pdfit)\n\n\nCompute the number of data points available in pdfit for comparison to model solution.\n\nThis is useful for caching a residual vector for least-squares fitting, e.g. with err_expT! and nls_pd!.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.obj_expT-Tuple{ODESolution, PrimaryDryFit}","page":"Reference","title":"LyoPronto.obj_expT","text":"obj_expT(sol, pdfit; tweight, verbose, Tvw_weight)\n\n\nEvaluate an objective function which compares model solution computed by sol to experimental data in pdfit.\n\nsol is a solution to an appropriate model; see gen_sol_pd for a helper.\npdfit is an instance of PrimaryDryFit, which contains some information about what to compare.\ntweight = 1 gives the weighting (in K^2/hr^2) of the total drying time in the objective, as compared to the temperature error.\nTvw_weight = 1 gives the weighting of Tvw in the objective, as compared to Tf.\n\nNote that if pdfit has vial wall temperatures (i.e. ismissing(pdfit.Tvws) == false), the third-index variable in sol is assumed to be temperature, as is true for the lumped capacitance model (see ParamObjRF`.\n\nIf there are multiple series of Tf in pdfit, squared error is computed for each separately then summed; likewise for Tvw.\n\nI've considered writing several methods and dispatching on pdfit somehow, which would be cool and might individually be easier to read. But control flow might be harder to document and explain, and this should work just fine.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.obj_pd-Tuple{Any, Any}","page":"Reference","title":"LyoPronto.obj_pd","text":"obj_pd(fitlog, tpf; tweight, Tvw_weight, badprms, verbose)\n\n\nCalculate the sum of squared error (objective function) for fitting parameters to primary drying data. This directly calls gen_sol_pd, then obj_expT, so see those docstrings.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.identify_pd_end-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.identify_pd_end","text":"identify_pd_end(t, pch_pir, kind; window_width, tmin, tmax)\n\n\nIdentify the end of primary drying using second derivative of Pirani pressure.\n\nArguments\n\nt: time points\npch_pir: Pirani pressure at given times\nkind: Val(:der2) for maximum of second derivative, Val(:onoff) for onset and offset.\nwindow_width: Width of the Savitzky-Golay filter window (default: 91)\ntmin: Minimum time for analysis (default: 0 hours, unitful)\ntmax: Maximum time for analysis (default: Inf hours, unitful)\n\nIf a single argument data is passed instead of t and pch_pir, the time and Pirani pressure are assumed to be  accessible as either data.t and data.pch_pir or data[:t] and data[:pch_pir].\n\nApproach\n\nUse a Savitzky-Golay filter to smooth and take derivatives. For the onset-offset, find linear intersects of tangent at inflection point with maximum and  minimum values of pressure. Those intersects are taken as onset and offset. For the second derivative, identify the maximum of the second derivative.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#Plot-Recipes","page":"Reference","title":"Plot Recipes","text":"","category":"section"},{"location":"alldocstrings/#LyoPronto.cycledataplot","page":"Reference","title":"LyoPronto.cycledataplot","text":"cycledataplot(tablelike, (Tname1, ...), Tsh_name, (p_name1, ...))\ncycledataplot!(tablelike, (Tname1, ...), Tsh_name, (p_name1, ...))\n\nPlot recipe for plotting both temperatures and pressures of a lyophilization cycle.\n\nThis requires at least two subplots, one for temperature and one for pressure. Either call twinx(plot()) then cycledataplot!(...), or give a layout like  cycledataplot(..., layout=(2,1))\"\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.cycledataplot!","page":"Reference","title":"LyoPronto.cycledataplot!","text":"cycledataplot(tablelike, (Tname1, ...), Tsh_name, (p_name1, ...))\ncycledataplot!(tablelike, (Tname1, ...), Tsh_name, (p_name1, ...))\n\nPlot recipe for plotting both temperatures and pressures of a lyophilization cycle.\n\nThis requires at least two subplots, one for temperature and one for pressure. Either call twinx(plot()) then cycledataplot!(...), or give a layout like  cycledataplot(..., layout=(2,1))\"\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.exppplot","page":"Reference","title":"LyoPronto.exppplot","text":"exppplot(t, p1, [p2, ...,], (name1, [name2, ...]))\nexppplot!(t, p1, [p2, ...,], (name1, [name2, ...]))\n\nPlot recipe for plotting pressures of a lyophilization cycle.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.exppplot!","page":"Reference","title":"LyoPronto.exppplot!","text":"exppplot(t, p1, [p2, ...,], (name1, [name2, ...]))\nexppplot!(t, p1, [p2, ...,], (name1, [name2, ...]))\n\nPlot recipe for plotting pressures of a lyophilization cycle.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.exptfplot","page":"Reference","title":"LyoPronto.exptfplot","text":"exptfplot(time, T1, [T2, ...]; nmarks=0, labsuffix=\", exp.\")\nexptfplot!(time, T1, [T2, ...]; nmarks=0, labsuffix=\", exp.\")\n\nPlot recipe for one or more experimentally measured product temperatures, all at same times. This recipe adds one series for each passed temperature series, with labels defaulting to \"T_{fi}\"*labsuffix.\n\nnmarks is an integer, indicating how many points to plot with markers, so that the number of markers is reasonable even with many data points. To plot all points (default), pass nmarks=0.\n\nsampmarks=false (default) will only show markers at selected points, while sampmarks=true will put a line through all points.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.exptfplot!","page":"Reference","title":"LyoPronto.exptfplot!","text":"exptfplot(time, T1, [T2, ...]; nmarks=0, labsuffix=\", exp.\")\nexptfplot!(time, T1, [T2, ...]; nmarks=0, labsuffix=\", exp.\")\n\nPlot recipe for one or more experimentally measured product temperatures, all at same times. This recipe adds one series for each passed temperature series, with labels defaulting to \"T_{fi}\"*labsuffix.\n\nnmarks is an integer, indicating how many points to plot with markers, so that the number of markers is reasonable even with many data points. To plot all points (default), pass nmarks=0.\n\nsampmarks=false (default) will only show markers at selected points, while sampmarks=true will put a line through all points.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.exptvwplot","page":"Reference","title":"LyoPronto.exptvwplot","text":"exptvwplot(time, T1, [T2, ...]; skip=1, nmarks=0, labsuffix=\", exp.\")\nexptvwplot!(time, T1, [T2, ...]; skip=1, nmarks=0, labsuffix=\", exp.\")\n\nPlot recipe for a set of experimentally measured vial wall temperatures. This recipe adds one series for each passed temperature series, with labels defaulting to \"T_{vwi}\"*labsuffix. skip is an integer, indicating how many points to skip at a time, so that  the dotted line looks dotted even with noisy data.\n\nnmarks is an integer, indicating how many points to plot with markers, so that the number of markers is reasonable even with many data points. To plot all points (default), pass nmarks=0.\n\nsampmarks=false (default) will only show markers at selected points, while sampmarks=true will put a line through all points.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.exptvwplot!","page":"Reference","title":"LyoPronto.exptvwplot!","text":"exptvwplot(time, T1, [T2, ...]; skip=1, nmarks=0, labsuffix=\", exp.\")\nexptvwplot!(time, T1, [T2, ...]; skip=1, nmarks=0, labsuffix=\", exp.\")\n\nPlot recipe for a set of experimentally measured vial wall temperatures. This recipe adds one series for each passed temperature series, with labels defaulting to \"T_{vwi}\"*labsuffix. skip is an integer, indicating how many points to skip at a time, so that  the dotted line looks dotted even with noisy data.\n\nnmarks is an integer, indicating how many points to plot with markers, so that the number of markers is reasonable even with many data points. To plot all points (default), pass nmarks=0.\n\nsampmarks=false (default) will only show markers at selected points, while sampmarks=true will put a line through all points.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.modconvtplot","page":"Reference","title":"LyoPronto.modconvtplot","text":"modconvtplot(sols; sampmarks=false, labsuffix = \", model\")\nmodconvtplot!(sols; sampmarks=false, labsuffix = \", model\")\n\nPlot recipe for one or multiple solutions to the Pikal model, e.g. the output of gen_sol_pd. This adds a series to the plot for each passed solution, with labels defaulting to \"T_{fi}\"*labsuffix.\n\nsampmarks=false (default) will only put a line through all points, while sampmarks=true will show markers at selected points.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.modconvtplot!","page":"Reference","title":"LyoPronto.modconvtplot!","text":"modconvtplot(sols; sampmarks=false, labsuffix = \", model\")\nmodconvtplot!(sols; sampmarks=false, labsuffix = \", model\")\n\nPlot recipe for one or multiple solutions to the Pikal model, e.g. the output of gen_sol_pd. This adds a series to the plot for each passed solution, with labels defaulting to \"T_{fi}\"*labsuffix.\n\nsampmarks=false (default) will only put a line through all points, while sampmarks=true will show markers at selected points.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.modrftplot","page":"Reference","title":"LyoPronto.modrftplot","text":"modrftplot(sol, labsuffix=\", model\", sampmarks=false, trimend=0)\nmodrftplot!(sol, labsuffix=\", model\", sampmarks=false, trimend=0)\n\nPlot recipe for one solution to the lumped capacitance model.\n\nThis adds two series to the plot, with labels defaulting to [\"T_f\" \"T_{vw}\"] .* labsuffix. The optional argument trimend controls how many time points to trim from the end (which is helpful if temperature shoots up as mf -> 0).\n\nSince this is a recipe, any Plots.jl keyword arguments can be passed to modify the plot.\n\nsampmarks=false (default) will only put a line through all points, while sampmarks=true will show markers at selected points.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.modrftplot!","page":"Reference","title":"LyoPronto.modrftplot!","text":"modrftplot(sol, labsuffix=\", model\", sampmarks=false, trimend=0)\nmodrftplot!(sol, labsuffix=\", model\", sampmarks=false, trimend=0)\n\nPlot recipe for one solution to the lumped capacitance model.\n\nThis adds two series to the plot, with labels defaulting to [\"T_f\" \"T_{vw}\"] .* labsuffix. The optional argument trimend controls how many time points to trim from the end (which is helpful if temperature shoots up as mf -> 0).\n\nSince this is a recipe, any Plots.jl keyword arguments can be passed to modify the plot.\n\nsampmarks=false (default) will only put a line through all points, while sampmarks=true will show markers at selected points.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.pressurenames-Tuple{String}","page":"Reference","title":"LyoPronto.pressurenames","text":"pressurenames(name)\n\nAttempt to catch common names or shorthands for Pirani and capacitance manometer, then give back a nice label.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.qrf_integrate-Tuple{Any, Any}","page":"Reference","title":"LyoPronto.qrf_integrate","text":"qrf_integrate(sol, RF_params)\n\nCompute the integral over time of each heat transfer mode in the lumped capacitance model.\n\nReturns as a Dict{String, Quantity{...}}, with string keys Qsub, Qshf, Qvwf, QRFf, QRFvw.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.tendplot","page":"Reference","title":"LyoPronto.tendplot","text":"tendplot(t_end)\ntendplot!(t_end)\ntendplot(t_end1, t_end2)\ntendplot!(t_end1, t_end2)\n\nPlot recipe that adds a labeled vertical line to the plot at time t_end.  A default label and styling are applied, but these can be modified by keyword arguments as usual If two time points are passed, a light shading is applied between instead of a vertical line.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.tendplot!","page":"Reference","title":"LyoPronto.tendplot!","text":"tendplot(t_end)\ntendplot!(t_end)\ntendplot(t_end1, t_end2)\ntendplot!(t_end1, t_end2)\n\nPlot recipe that adds a labeled vertical line to the plot at time t_end.  A default label and styling are applied, but these can be modified by keyword arguments as usual If two time points are passed, a light shading is applied between instead of a vertical line.\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#Vial-Dimensions","page":"Reference","title":"Vial Dimensions","text":"","category":"section"},{"location":"alldocstrings/#LyoPronto.get_vial_mass-Tuple{String}","page":"Reference","title":"LyoPronto.get_vial_mass","text":"get_vial_mass(vialsize)\n\n\nReturn vial mass for given ISO vial size.\n\nUses a table from a SCHOTT manual, stored internally in a CSV.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.get_vial_radii-Tuple{String}","page":"Reference","title":"LyoPronto.get_vial_radii","text":"get_vial_radii(vialsize)\n\n\nReturn inner and outer radius for passed ISO vial size.\n\nUses a table from a SCHOTT manual, stored internally in a CSV.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.get_vial_shape-Tuple{String}","page":"Reference","title":"LyoPronto.get_vial_shape","text":"get_vial_shape(vialsize::String)\n\nReturn a NamedTuple with a slew of vial dimensions, useful for drawing the shape of the vial with make_outlines.\n\nUses a table from a SCHOTT manual, stored internally in a CSV.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.get_vial_thickness-Tuple{String}","page":"Reference","title":"LyoPronto.get_vial_thickness","text":"get_vial_thickness(vialsize)\n\n\nReturn vial wall thickness for given ISO vial size.\n\nUses a table from a SCHOTT manual, stored internally in a CSV.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.make_outlines-Tuple{Any, Any}","page":"Reference","title":"LyoPronto.make_outlines","text":"make_outlines(dims, Vfill)\n\nReturn a sequence of points (ready to be made into Plots.Shapes for the vial and fill volume, with Unitful dimensions, for given vial dimensions.\n\nThis is a convenience function for making figures illustrating fill depth.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#Model-Equations","page":"Reference","title":"Model Equations","text":"","category":"section"},{"location":"alldocstrings/#LyoPronto.end_drying_callback","page":"Reference","title":"LyoPronto.end_drying_callback","text":"A callback for use in simulating either the Pikal or RF model.\n\nTerminates the time integration when end_cond evaluates to true.\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.lyo_1d_dae_f","page":"Reference","title":"LyoPronto.lyo_1d_dae_f","text":"lyo_1d_dae_f = ODEFunction(lyo_1d_dae!, mass_matrix=lyo_1d_mm)\n\nCompute the right hand side function for the Pikal model.\n\nThe DAE system which is the Pikal model (1 ODE, one nonlinear algebraic equation for pseudosteady conditions) is here treated as a constant-mass-matrix implicit ODE system. The implementation is in lyo_1d_dae!\n\nThe initial conditions u0 = [h_f, Tf] should be unitless, but are internally assigned to be in [cm, K]. The unitless time is taken to be in hours, so derivatives are given in unitless [cm/hr, K/hr].\n\nparams is a ParamObjPikal, which can be constructed with the following form (helping with readability):\n\nparams = ParamObjPikal((\n    (Rp, hf0, csolid, ρsolution),\n    (Kshf, Av, Ap),\n    (pch, Tsh) ,\n))\n\nwhere those listed following are callables returning Quantitys, and the rest are Quantitys. See RpFormFit and RampedVariable for convenience types that can help with the callables.\n\nRp(x) with x a length returns mass transfer resistance (as a Unitful quantity)\nKshf(p) with p a pressure returns heat transfer coefficient (as a Unitful quantity).\nTsh(t), pch(t) return shelf temperature and chamber pressure respectively at time t.\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.ParamObjPikal","page":"Reference","title":"LyoPronto.ParamObjPikal","text":"struct ParamObjPikal{__T_Rp, __T_hf0, __T_csolid, __T_ρsolution, __T_Kshf, __T_Av, __T_Ap, __T_pch, __T_Tsh} <: LyoPronto.ParamObj\n\nThe ParamObjPikal type is a container for the parameters used in the Pikal model.\n\n\n\n\n\n","category":"type"},{"location":"alldocstrings/#LyoPronto.ParamObjRF","page":"Reference","title":"LyoPronto.ParamObjRF","text":"struct ParamObjRF{__T_Rp, __T_hf0, __T_csolid, __T_ρsolution, __T_Kshf, __T_Av, __T_Ap, __T_pch, __T_Tsh, __T_P_per_vial, __T_mf0, __T_cpf, __T_mv, __T_cpv, __T_Arad, __T_f_RF, __T_eppf, __T_eppvw, __T_Kvwf, __T_Bf, __T_Bvw, __T_alpha} <: LyoPronto.ParamObj\n\nThe ParamObjRF type is a container for the parameters used in the RF model.\n\n\n\n\n\n","category":"type"},{"location":"alldocstrings/#LyoPronto.calc_md_Q-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.calc_md_Q","text":"calc_md_Q(u, po, t)\n\n\nWith the Pikal model, compute the mass flow at u=[hf, Tf], time t, and conditions po. Ideally po should be a ParamObjPikal.\n\nThis gets used inside the DAE solve, but for consistency is provided separately so to avoid the risk of making unit mistakes.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.end_cond-Tuple{Any, Any, Any}","page":"Reference","title":"LyoPronto.end_cond","text":"end_cond(u, t, integ)\n\nCompute the end condition for primary drying (that mf or hf approaches zero).\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.lumped_cap_rf!","page":"Reference","title":"LyoPronto.lumped_cap_rf!","text":"lumped_cap_rf!(du, u, params, tn)\nlumped_cap_rf!(du, u, params, tn, qret)\n\n\nCompute the right-hand-side function for the ODEs making up the lumped-capacitance microwave-assisted model.\n\nThe optional argument qret defaults to Val(false); if set to Val(true), the function returns [Q_sub, Q_shf, Q_vwf, Q_RF_f, Q_RF_vw, Q_shw] with Q_... as Unitful quantities in watts.  The extra results are helpful in investigating the significance of the various heat transfer  modes, but are not necessary in the ODE integration.\n\ndu refers to [dmf/dt, dTf/dt, dTvw/dt], with u = [mf, Tf, Tvw]. u is taken without units but assumed to have the units of [g, K, K] (which is internally added). tn is assumed to be in hours (internally added), so dudt is returned with assumed units [g/hr, K/hr, K/hr] to be consistent.\n\nIt is recommended to use the ParamObjRF type to hold the parameters, since it allows some more convenient access to the parameters, but they can be given in the form of a  tuple-of-tuples:\n\nparams = (   \n    (Rp, hf0, cSolid, ρsolution),\n    (Kshf_f, Av, Ap),\n    (pch, Tsh, P_per_vial),\n    (mf0, cpf, mv, cpv, Arad),\n    (f_RF, eppf, eppvw),\n    (Kvwf, Bf, Bvw, alpha),\n)\n\nThis tuple-of-tuples structure is also used in an extra constructor for the ParamObjRF type.\n\nThese should all be Unitful quantities with appropriate dimensions, with some exceptions which are callables returning quantities. See RpFormFit and RampedVariable for convenience types that can help with these cases.\n\nRp(x) with x a length returns mass transfer resistance (as a Unitful quantity)\nKshf_f(p) with p a pressure returns heat transfer coefficient (as a Unitful quantity).\nTsh(t), pch(t), P_per_vial(t) return shelf temperature, chamber pressure, and microwave power respectively at time t.\nArad and alpha are used only in prior versions of the model, and can be left out.\n\nThis is my updated version of the model. LC3: Q_shw evaluated with Kshf; shape factor included; α=0\n\n\n\n\n\n","category":"function"},{"location":"alldocstrings/#LyoPronto.lyo_1d_dae!-NTuple{4, Any}","page":"Reference","title":"LyoPronto.lyo_1d_dae!","text":"lyo_1d_dae!(du, u, params, t)\n\nInternal implementation of the Pikal model. See lyo_1d_dae_f for the wrapped version, which is more fully documented.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#Physical-Properties","page":"Reference","title":"Physical Properties","text":"","category":"section"},{"location":"alldocstrings/#LyoPronto.Mw","page":"Reference","title":"LyoPronto.Mw","text":"Molecular weight of water\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.cp_gl","page":"Reference","title":"LyoPronto.cp_gl","text":"Glass heat capacity Rough estimate from Bansal and Doremus 1985, \"Handbook of Glass Properties\"\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.cp_ice","page":"Reference","title":"LyoPronto.cp_ice","text":"Ice heat capacity IAPWS for ice: use triple point value for simplicity\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.e_0","page":"Reference","title":"LyoPronto.e_0","text":"Permittivity of free space\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.k_gl","page":"Reference","title":"LyoPronto.k_gl","text":"Glass thermal conductivity From Bansal and Doremus 1985, rough estimate based an a sodium borosilicate glass\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.k_ice","page":"Reference","title":"LyoPronto.k_ice","text":"Thermal conductivity of ice From Slack, 1980 200K : .032 W/cmK 250K : .024 W/cmK 273K : .0214 W/cmK\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.k_sucrose","page":"Reference","title":"LyoPronto.k_sucrose","text":"Thermal conductivity of sucrose, Caster grade powder From McCarthy and Fabre, 1989 book chapter\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.rho_ice","page":"Reference","title":"LyoPronto.rho_ice","text":"Density of ice at triple point.\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.ΔHsub","page":"Reference","title":"LyoPronto.ΔHsub","text":"Heat of sublimation of ice Approximate: coresponds to 254K or 225K From Feistel and Wagner, 2006\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.εpp_gl","page":"Reference","title":"LyoPronto.εpp_gl","text":"Dielectric loss coefficient of borosilicate glass, per Schott's testing\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.μ_vap","page":"Reference","title":"LyoPronto.μ_vap","text":"Water vapor viscosity in dilute limit\n\nFrom Hellmann and Vogel, 2015 250K: 8.054 μPas 260K: 8.383 μPas 270K: 8.714 μPa*s\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.ρ_gl","page":"Reference","title":"LyoPronto.ρ_gl","text":"Glass density SCHOTT measurement, posted online\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.ρ_sucrose","page":"Reference","title":"LyoPronto.ρ_sucrose","text":"Density of sucrose, Caster grade powder From McCarthy and Fabre, 1989 book chapter\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.σ","page":"Reference","title":"LyoPronto.σ","text":"Stefan-Boltzmann Constant\n\n\n\n\n\n","category":"constant"},{"location":"alldocstrings/#LyoPronto.calc_Tsub-Tuple{Q} where Q<:(Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U})","page":"Reference","title":"LyoPronto.calc_Tsub","text":"Using the same Arrhenius fit as calc_psub, compute the sublimation temperature at a given pressure.\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.calc_psub-Tuple{Any}","page":"Reference","title":"LyoPronto.calc_psub","text":"calc_psub(T) \ncalc_psub(T::Q) where Q<:Quantity\n\nCompute pressure (in Pascals) of sublimation at temperature T in Kelvin.\n\nThis is essentially an Arrhenius fit, where we compute: psub = pref * exp(-ΔHsub*Mw/R/T)\n\n\n\n\n\n","category":"method"},{"location":"alldocstrings/#LyoPronto.Dielectric","page":"Reference","title":"LyoPronto.Dielectric","text":"Single-purpose module for computing the dielectric loss coefficient of ice, as a function of temperature and frequency. This module exports a function ϵppf(T, f) for doing so. (Set as a separate module just to keep namespaces clean.) This code is a nearly-direct implementation of the correlation, Eqs. 3-6 presented in: Takeshi Matsuoka, Shuji Fujita, Shinji Mae; Effect of temperature on dielectric properties of ice in the range 5–39 GHz. J. Appl. Phys. 15 November 1996; 80 (10): 5884–5890. https://doi.org/10.1063/1.363582\n\n\n\n\n\n","category":"module"},{"location":"alldocstrings/#LyoPronto.Dielectric.ϵppf","page":"Reference","title":"LyoPronto.Dielectric.ϵppf","text":"ϵppf(T, f)\n\nCompute the dielectric loss of ice as a function of temperature and frequency. Expects temperature in Kelvin and frequency in Hz, with Unitful units.\n\n\n\n\n\n","category":"function"},{"location":"generated/utilities/#Imports","page":"Other tools","title":"Imports","text":"","category":"section"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"LyoPronto is this package. It reexports several other packages, so after using LyoPronto, you have effectively also done using Unitful and a few others.","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"using LyoPronto","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"These are other packages that I use in the test suite, but you can use others in their place. TypedTables provides a lightweight table structure, not as broadly flexible as a DataFrame but great for our needs","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"using TypedTables, CSV","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"Plots is a frontend for several plotting packages, and its companion package StatsPlots has a very nice macro I like.","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"using Plots\nusing StatsPlots: @df\nusing LaTeXStrings","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"For dealing with parameter structs and making copies, Accessors provides the @set and @reset macros","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"using Accessors","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"For helping make some nice plot labels","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"using Latexify: latexify, set_default\nset_default(labelformat=:square) # Sets a Latexify default","category":"page"},{"location":"generated/utilities/#Example-Process-Data","page":"Other tools","title":"Example Process Data","text":"","category":"section"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"# Data start at 8th row of CSV file.\n# This needs to point to the right file, which for documentation is kinda wonky\nprocdata_raw = CSV.read(joinpath(@__DIR__, \"..\", \"..\", \"example\", \"2024-06-04-10_MFD_AH.csv\"), Table, header=8)\nt = uconvert.(u\"hr\", procdata_raw.CycleTime .- procdata_raw.CycleTime[1])\n# At midnight, timestamps revert to zero, so catch that case\nfor i in eachindex(t)[begin+1:end]\n    if t[i] < t[i-1]\n        t[i:end] .+= 24u\"hr\"\n    end\nend\n# Some of the dispatches don't like if time is not a float\nt = float.(t)\n\n# Rename the columns we will use, and add units\nprocdata = map(procdata_raw) do row\n    # In the anonymous `do` function, `row` is a row of the table.\n    # Return a new row as a NamedTuple\n    (pirani = row.VacPirani * u\"mTorr\",\n     cm = row.VacCPM * u\"mTorr\",\n     T1 = row.TP1 * u\"°C\",\n     T2 = row.TP2 * u\"°C\",\n     T3 = row.TP4 * u\"°C\", # Quirk of this experimental run: TP3 slot was empty\n     Tsh = row.ShelfSetPT * u\"°C\",\n     phase = row.Phase # identify whether freezing, primary drying, or secondary\n    )\nend\nprocdata = Table(procdata, (;t)) # Append time to table\n\n# Count time from the beginning of experiment\npd_data = filter(row->row.phase == 4, procdata)\ntstart_pd = pd_data.t[1]\npd_data.t .-= pd_data.t[1]\n\nt_end = identify_pd_end(pd_data.t, pd_data.pirani, Val(:onoff))","category":"page"},{"location":"generated/utilities/#Example-models","page":"Other tools","title":"Example models","text":"","category":"section"},{"location":"generated/utilities/#Conventional-lyophilization","page":"Other tools","title":"Conventional lyophilization","text":"","category":"section"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"# Vial geometry\n# Ran with a 10mL vial, not strictly a 10R but with similar dimensions\nAp, Av = π.*get_vial_radii(\"10R\") .^ 2\n\n# Experimental conditions\nT_shelf_0 = -40.0u\"°C\" |> u\"K\" # initial shelf temperature, in Kelvin for math reasons\nT_shelf_final = -10.0u\"°C\" |> u\"K\" # final shelf temperature\nramp_rate = 0.5 *u\"K/minute\" # ramp rate\n# Set points, followed, by ramp rate, followed by hold times if there are multiple ramps\nTsh = RampedVariable([T_shelf_0, T_shelf_final], ramp_rate)\n# Single set point with no ramps\npch = RampedVariable(100u\"mTorr\")\n\n# Formulation parameters\ncsolid = 0.05u\"g/mL\" # g solute / mL solution\nρsolution = 1u\"g/mL\" # g/mL total solution density\n# Previously fitted values for Rp\nR0 = 0.93u\"cm^2*Torr*hr/g\"\nA1 = 21.1u\"cm*Torr*hr/g\"\nA2 = 1.2u\"1/cm\"\nRp = RpFormFit(R0, A1, A2)\n# Fit value for heat transfer coeff\nKshf = ConstPhysProp(13.9u\"W/m^2/K\")\n\n# Fill\nVfill = 3u\"mL\"\nhf0 = Vfill / Ap\n\npo = ParamObjPikal([\n    (Rp, hf0, csolid, ρsolution),\n    (Kshf, Av, Ap),\n    (pch, Tsh)\n]);\n\nprob = ODEProblem(po)\nsol_conv = solve(prob, Rodas3());\nnothing #hide","category":"page"},{"location":"generated/utilities/#System-setpoints-and-conditions-with-RampedVariables","page":"Other tools","title":"System setpoints and conditions with RampedVariables","text":"","category":"section"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"Because it is very common to have a gradual ramp in temperature at the start of drying (and in general any time the set point changes), LyoPronto provides a tool for concisely describing the set point over time.","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"For a constant set point (with no ramps), provide a single value:","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"Tsh1 = RampedVariable(-15u\"°C\")","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"For a ramp from freezing temperature followed by a single hold (as is common in primary drying), provide the initial temperature, target temperature, and ramp rate:","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"# Convert from Celsius to Kelvin so that algebra can happen on backend\nTsh2 = RampedVariable([-40.0, -10]u\"°C\" .|> u\"K\", 1.0u\"K/minute\")","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"For multiple ramps, provide set points, then ramp rates, then hold times in between ramps. In general, supply one less ramp than set points, and one less hold time than ramps.","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"Tsh3 = RampedVariable([-40, -20, 0]u\"°C\" .|> u\"K\", [2//3, 0.5]u\"K/minute\", [1u\"hr\"])","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"A plot recipe is provided for all of these RampedVariables.","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"plot(xunit=u\"hr\", xlimit=(-0.1u\"hr\", 2.5u\"hr\"))\nplot!(Tsh1, lw=3, label=\"No ramp\")\nplot!(Tsh2, lw=3, label=\"1 ramp\")\nplot!(Tsh3, lw=3, label=\"2 ramps\")","category":"page"},{"location":"generated/utilities/#Estimating-Rp-over-time","page":"Other tools","title":"Estimating Rp over time","text":"","category":"section"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"The standard (Pikal) model for primary drying in lyophilization consists of, fundamentally, one ODE (change in frozen layer height) with a nonlinear algebraic constraint (pseudosteady heat and mass transfer, coupled at sublimation front). Since we have a system with one ODE and one nonlinear algebraic constraint, there is only one degree of freedom at a given time point. So with temperature measurements over time, we can compute corresponding mass flow over time or mass transfer resistance over length.","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"In LyoPronto, this functionality is implemented with the [calc_hRp_T](@ref) function, (think \"compute Rp(h_d) from T_f(t)\").","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"To do so, we need to know about the experimental conditions; for that purpose, we pass a ParamObjPikal containing that information. To deal with the actual temperature series, we use a PrimaryDryFit object, which allows us to encode the way that, at some point, each temperature series deviates from the regular pseudosteady behavior governed by this model. (Strictly speaking, there are a variety of phenomena involved, but for here it is enough to say that at some point in time each temperature series experiences a sharp rise that is not described by the model.)","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"# The PrimaryDryFit:\nfitdat_all = @df pd_data PrimaryDryFit(:t, (:T1[:t .< 15u\"hr\"],\n                                    :T2[:t .< 13u\"hr\"],\n                                    :T3[:t .< 16u\"hr\"]),)\nplot(fitdat_all, nmarks=30, sampmarks=true)","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"Note that in this plot, T1 rises after 13 hours–I have deliberately included that to show what this will do in R_p(h_d) space. Now, with the ParamObjPikal and PrimaryDryFit defined, we can calculate R_p(h_d):","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"# Compute just for the first temperature series\ncalc_hRp_T(po, fitdat_all, i=1)\n# Compute for all temperature series\nhRps = [calc_hRp_T(po, fitdat_all; i) for i in 1:3]","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"This returned a vector tuples, with a vector each for h_d(t) and R_p(t) for each set of temperature measurements. To plot this against a temperature fit as in the other tutorial here, we can do the following:","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"pl = plot(xlabel=\"h_d\", ylabel=\"R_p\", unitformat=latexify, xunit=u\"cm\", yunit=u\"cm^2*Torr*hr/g\")\nfor (i, hRp) in enumerate(hRps)\n    plot!(hRp[1], hRp[2], label=\"T$i\")\nend\n# For comparison, plot Rp as computed from fit in the other example\nl = range(0u\"cm\", hf0, length=100)\nplot!(l, Rp.(l), label=\"Direct fit to \\$T(t)\\$\")","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"","category":"page"},{"location":"generated/utilities/","page":"Other tools","title":"Other tools","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#LyoPronto.jl","page":"Home","title":"LyoPronto.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package providing common computations for pharmaceutical lyophilization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This provides some of the functionality of LyoPRONTO, a Python package.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This relatively small package provides a standard literature model for simulating primary drying in pharmaceutical lyophilization, alongside robust utilities for a common parameter estimation workflow. This same infrastructure is provided for a model that adds microwave heating.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some key advantages this has over the original version of LyoPRONTO are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Speed: on my laptop, the regular model can be simulated in about a millisecond. This becomes most relevant when evaluating the model repeatedly in parameter estimation or constructing large design spaces.\nNumerical reliability: in the original LyoPRONTO, bad parameter values (e.g. if input with wrong units or uninformed guesses) easily lead to infinite loops due to the numerical approach used. As a side effect of using a modern library for fast DAE solution, numerical instability errors out instead of hitting an infinite loop. \nUnits: by using Unitful.jl, this package enforces dimensional correctness while being compatible with either SI marks or traditional units in lyophilization (like cm^2 hr Torr  g for R_p).\nFlexibility: the utilities for fitting K_v and R_p can be used together to fit both at once, not just separately.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a Julia package, this code can be easily installed with the Julia package manager. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"From the Julia REPL's Pkg mode (open a REPL and type ] so that the prompt turns blue), add this package as a Git repo:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/LyoHUB/LyoPronto.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"dev can be substituted for add if you want to make changes to this package yourself, as explained in the Julia Pkg manual.","category":"page"},{"location":"#Dependencies-and-Reexports","page":"Home","title":"Dependencies and Reexports","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package leverages the strengths of the DifferentialEquations.jl ecosystem to solve equations quickly and efficiently, although it only directly depends on OrdinaryDiffEqRosenbrock and DiffEqCallbacks, which are both reexported.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also provided are plot recipes for Plots.jl, although this package only depends on RecipesBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Heavy use is made of Unitful.jl, which is reexported.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Written by Isaac S. Wheeler, a PhD student at Purdue University. This work was supported in part by funding for NIIMBL project PC4.1-307 .","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"None yet. My intentions are to use the MIT license once this has been published in a scientific journal.","category":"page"},{"location":"generated/all_recipes/#Imports","page":"Plot recipes","title":"Imports","text":"","category":"section"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"LyoPronto is this package. It reexports several other packages, so after using LyoPronto, you have effectively also done using Unitful and a few others.","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"using LyoPronto","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"These are other packages that I use in the test suite, but you can use others in their place. TypedTables provides a lightweight table structure, not as broadly flexible as a DataFrame but great for our needs","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"using TypedTables, CSV","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"Plots is a frontend for several plotting packages, and its companion package StatsPlots has a very nice macro I like.","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"using Plots\nusing StatsPlots: @df\nusing LaTeXStrings","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"For dealing with parameter structs and making copies, Accessors provides the @set and @reset macros","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"using Accessors","category":"page"},{"location":"generated/all_recipes/#Note-on-recipes","page":"Plot recipes","title":"Note on recipes","text":"","category":"section"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"All of the below recipes are implemented with the Plots.jl recipe system.","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"One feature is that each of these functions has a version that produces a new plot and one that modifies an existing plot which differ by a bang: exptfplot(...) produces a new plot, while exptfplot!(...) adds to an existing plot.","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"Another is that you can pass any Plots keyword arguments to any of the plot calls, such as to override the default colors or labels provided by the recipes.","category":"page"},{"location":"generated/all_recipes/#Read-Process-Data","page":"Plot recipes","title":"Read Process Data","text":"","category":"section"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"# Data start at 8th row of CSV file.\n# This needs to point to the right file, which for documentation is kinda wonky\nprocdata_raw = CSV.read(joinpath(@__DIR__, \"..\", \"..\", \"example\", \"2024-06-04-10_MFD_AH.csv\"), Table, header=8)\nt = uconvert.(u\"hr\", procdata_raw.CycleTime .- procdata_raw.CycleTime[1])\n# At midnight, timestamps revert to zero, so catch that case\nfor i in eachindex(t)[begin+1:end]\n    if t[i] < t[i-1]\n        t[i:end] .+= 24u\"hr\"\n    end\nend\n# Some of the dispatches don't like if time is not a float\nt = float.(t)\n\n# Rename the columns we will use, and add units\nprocdata = map(procdata_raw) do row\n    # In the anonymous `do` function, `row` is a row of the table.\n    # Return a new row as a NamedTuple\n    (pirani = row.VacPirani * u\"mTorr\",\n     cm = row.VacCPM * u\"mTorr\",\n     T1 = row.TP1 * u\"°C\",\n     T2 = row.TP2 * u\"°C\",\n     T3 = row.TP4 * u\"°C\", # Quirk of this experimental run: TP3 slot was empty\n     Tsh = row.ShelfSetPT * u\"°C\",\n     phase = row.Phase # identify whether freezing, primary drying, or secondary\n    )\nend\nprocdata = Table(procdata, (;t)) # Append time to table\n\n# Count time from the beginning of experiment\npd_data = filter(row->row.phase == 4, procdata)\ntstart_pd = pd_data.t[1]\npd_data.t .-= pd_data.t[1]\n\nt_end = identify_pd_end(pd_data.t, pd_data.pirani, Val(:onoff))\n\nT_shelf_0 = -40.0u\"°C\" |> u\"K\" # initial shelf temperature, in Kelvin for math reasons\nT_shelf_final = -10.0u\"°C\" |> u\"K\" # final shelf temperature\nramp_rate = 0.5 *u\"K/minute\" # ramp rate\n# Set points, followed, by ramp rate, followed by hold times if there are multiple ramps\nTsh = RampedVariable([T_shelf_0, T_shelf_final], ramp_rate)\n# Single set point with no ramps\npch = RampedVariable(100u\"mTorr\")","category":"page"},{"location":"generated/all_recipes/#Cycle-Data-Recipes","page":"Plot recipes","title":"Cycle Data Recipes","text":"","category":"section"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"Plots provides a very convenient macro @df which inserts table columns into a function call, which is very handy for plotting. We will use this liberally.","category":"page"},{"location":"generated/all_recipes/#Pressure-plotting-and-end-of-drying","page":"Plot recipes","title":"Pressure plotting and end of drying","text":"","category":"section"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"@df pd_data exppplot(:t, :pirani, :cm, (\"Pirani\", \"CM\"))\ntendplot!(t_end)\nsavefig(\"recipe_pressure.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"@df pd_data exppplot(:t, :cm, :pirani, (\"cap\", \"pir\"))\ntendplot!(t_end[1])\nsavefig(\"recipe_pressure_alt.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/#Temperature-plotting","page":"Plot recipes","title":"Temperature plotting","text":"","category":"section"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"@df procdata exptfplot(:t, :T1, :T2, nmarks=40, sampmarks=true, linealpha=0.2)\n@df procdata exptvwplot!(:t, :T3, nmarks=30, sampmarks=true, linealpha=0.2)\nsavefig(\"recipe_temp.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"@df pd_data exptfplot(:t, :T1, :T2, labsuffix = \" prod\")\n@df pd_data exptvwplot!(:t, :T3, labsuffix = \" vial\")\nsavefig(\"recipe_temp_alt.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/#Plot-all-cycle-data-at-once-with-a-slick-recipe","page":"Plot recipes","title":"Plot all cycle data at once with a slick recipe","text":"","category":"section"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"twinx(plot(xunit=u\"hr\",))\ncycledataplot!(procdata, (:T1, :T2, :T3), :Tsh, (:pirani, :cm), pcolor=:green, nmarks=30)\nplot!(subplot=1, legend=:left)\nplot!(subplot=2, ylim=(0, 200), legend=:bottomright)\nsavefig(\"recipe_tp.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"If you want more granular control, you can expand this into its component pieces:","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"# set up plot\ntwinx(plot())\n# plot data\n@df procdata plot!(:t, :Tsh, color=:black, label=L\"T_\\mathrm{sh}\", lw=2, subplot=1)\n@df procdata exptfplot!(:t, :T1, :T2, :T3, lw=2, subplot=1, nmarks=30)\n# style the axes\nplot!(subplot=1, xlabel=\"Time\", ylabel=\"Temperature\", ygrid=true, legend=:left)\n# plot on secondary axis\n@df procdata exppplot!(:t, :pirani, :cm, (\"Pirani\", \"CM\"), c=:green, subplot=2)\n# style second axis\nplot!(subplot=2, ylabel=\"Pressure\", foreground_color_axis=:green, bordercolor=:green,\n    seriescolor=:green)\nplot!(subplot=2, ylim=(0, 200), legend=:bottomright)\nsavefig(\"tp_recipe_comps.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/#Fitting-Object-Recipes","page":"Plot recipes","title":"Fitting Object Recipes","text":"","category":"section"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"As a reminder, the PrimaryDryFit object is a container for the data we will use in fitting–no actual iterations are happening yet. This object has a plot recipe, useful for examining what you are feeding to the fit:","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"fitdat_all = @df pd_data PrimaryDryFit(:t, (:T1[:t .< 13u\"hr\"],\n                                    :T2[:t .< 13u\"hr\"],\n                                    :T3[:t .< 16u\"hr\"]);\n                                    t_end)\nplot(fitdat_all, nmarks=30)\nsavefig(\"recipe_pdfit.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"If T3 were instead a vial wall temperature measurement and we don't want the optimizer to take drying time into account we could provide and plot it as such.","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"# Note that we pass T1 and T2 in a tuple as frozen temperatures, then T3 as a next argument\nfitdat_vw = @df pd_data PrimaryDryFit(:t, (:T1[:t .< 13u\"hr\"],\n                                    :T2[:t .< 13u\"hr\"]);\n                                    Tvws=:T3[:t .< 16u\"hr\"],)\nplot(fitdat_vw, nmarks=40)\nsavefig(\"recipe_pdfitvw.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"In lack of a better place, it is also worth mentioning that RampedVariable structs have a plotting recipe as well. Since the end time isn't specified by the struct, specify it in the plot recipe.","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"plot(Tsh, tmax=5u\"hr\")\nsavefig(\"recipe_rv.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"plot(pch)","category":"page"},{"location":"generated/all_recipes/#Example-models","page":"Plot recipes","title":"Example models","text":"","category":"section"},{"location":"generated/all_recipes/#Conventional-lyophilization","page":"Plot recipes","title":"Conventional lyophilization","text":"","category":"section"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"# Vial geometry\n# Ran with a 10mL vial, not strictly a 10R but with similar dimensions\nAp, Av = π.*get_vial_radii(\"10R\") .^ 2\n\n# Formulation parameters\ncsolid = 0.05u\"g/mL\" # g solute / mL solution\nρsolution = 1u\"g/mL\" # g/mL total solution density\n# Previously fitted values for Rp\nR0 = 0.93u\"cm^2*Torr*hr/g\"\nA1 = 21.1u\"cm*Torr*hr/g\"\nA2 = 1.2u\"1/cm\"\nRp = RpFormFit(R0, A1, A2)\n# Fit value for heat transfer coeff\nKshf = ConstPhysProp(13.9u\"W/m^2/K\")\n\n# Fill\nVfill = 3u\"mL\"\nhf0 = Vfill / Ap\n\n# Cycle parameters\n\npo = ParamObjPikal([\n    (Rp, hf0, csolid, ρsolution),\n    (Kshf, Av, Ap),\n    (pch, Tsh)\n]);\n\nprob = ODEProblem(po)\nsol_conv = solve(prob, Rodas3());\n\n# Make some alternate versions for showing in plots\npo_alt1 = @set po.Kshf.val = 16u\"W/m^2/K\"\npo_alt2 = @set po.Kshf.val = 10u\"W/m^2/K\"\nsol_calt1 = solve(ODEProblem(po_alt1), Rodas3())\nsol_calt2 = solve(ODEProblem(po_alt2), Rodas3());\nnothing #hide","category":"page"},{"location":"generated/all_recipes/#Microwave-assisted-lyophilization","page":"Plot recipes","title":"Microwave-assisted lyophilization","text":"","category":"section"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"A few more physical properties and fit parameters need to be provided:","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"cpf = LyoPronto.cp_ice\ncpv = LyoPronto.cp_gl\nmv = get_vial_mass(\"10R\")\nmf0 = Vfill * ρsolution\n# Microwave field-related parameters\nf_RF = 8u\"GHz\"\nepp_f = LyoPronto.ϵppf\nepp_w = LyoPronto.epp_gl\n# Fit parameters\nBf = 2.0e7u\"Ω/m^2\"\nBvw = 0.9e7u\"Ω/m^2\"\nKvwf = 2.4u\"W/K/m^2\"\n# Microwave power per vial\nP_per_vial = RampedVariable(10u\"W\"/17 * 0.54) # actual input power / vial\n\npo_rf = ParamObjRF((\n    (Rp, hf0, csolid, ρsolution),\n    (Kshf, Av, Ap),\n    (pch, Tsh, P_per_vial),\n    (mf0, cpf, mv, cpv),\n    (f_RF, epp_f, epp_w),\n    (Kvwf, Bf, Bvw),\n))\n\nprob = ODEProblem(po_rf)\nsol_rf = solve(prob, Rodas3());\nnothing #hide","category":"page"},{"location":"generated/all_recipes/#Plot-Recipes-for-Solution-Objects","page":"Plot recipes","title":"Plot Recipes for Solution Objects","text":"","category":"section"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"For conventional drying, we only need to plot temperatures of the frozen layer:","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"modconvtplot(sol_conv, sampmarks=true)\nsavefig(\"recipe_pikal.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"We can show multiple solutions at once:","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"modconvtplot(sol_conv, sol_calt1, sol_calt2)\nsavefig(\"recipe_multipikal.svg\") #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"For microwave-assisted drying, we also need to plot vial wall temperatures:","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"modrftplot(sol_rf, sampmarks=true)\nsavefig(\"recipe_rf.svg\"); #md #hide\nnothing #hide","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"(Image: )","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"","category":"page"},{"location":"generated/all_recipes/","page":"Plot recipes","title":"Plot recipes","text":"This page was generated using Literate.jl.","category":"page"}]
}
